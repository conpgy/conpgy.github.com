<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | 无着的博客]]></title>
  <link href="http://conpgy.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://conpgy.github.io/"/>
  <updated>2014-09-03T22:02:08+08:00</updated>
  <id>http://conpgy.github.io/</id>
  <author>
    <name><![CDATA[无着]]></name>
    <email><![CDATA[conpgy@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS应用存储方式之Plist、Preference和NSKeyedArchiver]]></title>
    <link href="http://conpgy.github.io/blog/2014/09/03/iosying-yong-cun-chu-fang-shi-zhi-plist%2C-preferencehe-nskeyedarchiver/"/>
    <updated>2014-09-03T21:57:05+08:00</updated>
    <id>http://conpgy.github.io/blog/2014/09/03/iosying-yong-cun-chu-fang-shi-zhi-plist,-preferencehe-nskeyedarchiver</id>
    <content type="html"><![CDATA[<h3>iOS应用数据存储方式</h3>

<ul>
<li><p>XML属性列表（plist）归档</p></li>
<li><p>Preference（偏好设置）</p></li>
<li><p>NSkeyedArchiver归档(NSCoding)</p></li>
<li><p>SQLite3</p></li>
<li><p>Core Data</p></li>
</ul>


<!-- more -->


<h5>应用沙盒</h5>

<p>每个iOS应用都有自己的应用沙盒(文件系统目录),与其他文件系统隔离。应用必须待在自己的沙盒里，其他应用不能访问该沙盒。</p>

<ul>
<li>Documents: 保存应用程序运行时生成的需要持久化的数据，iTunes同步设备时会备份该目录。例如，游戏应用可将游戏归档保存在该目录。</li>
<li>tmp: 保存应用运行时所需的临时数据，使用完毕后再将相应的文件从该目录删除。应用没有运行时，系统也可能会清除该目录下的文件。iTunes同步设备时不会同步该目录。</li>
<li>Library/Caches: 保存应用运行时生成的需要持久化的数据，iTunes同步设备时不会备份该目录。一般存储体积大，不需要备份的非重要数据。</li>
<li>Library/Preference: 保存应用所有的偏好设置，iOS的Settings(设置)应用会在该目录中查找应用的设置的设置信息。iTunes同步设备时会备份该目录。</li>
</ul>


<h5>应用沙盒的常见获取方式</h5>

<p>沙盒根目录：</p>

<pre><code>NSString *home = NSHomeDirectory();
</code></pre>

<p><strong>Documents:(2种方式)</strong></p>

<p>一. 利用沙盒根目录拼接"Documents"字符串</p>

<pre><code>NSString *home = NSHomeDirectory();
NSString *documents = [home stringByAppendingPathComponent:@"Documents"];
// 不建议，新版本操作系统可能会修改该目录名
</code></pre>

<p>二. 利用NSSearchPathForDirectoriesInDomain函数</p>

<pre><code>// NSUserDomainMask 代表从用户文件夹下找
// YES 代表展开路径中的波浪字符“~”
NSArray *array =  NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, NO);
// 在iOS中，只有一个目录跟传入的参数匹配，所以这个集合里面只有一个元素
NSString *documents = [array objectAtIndex:0];
</code></pre>

<p><strong>tmp: NSString *tmp = NSTempraryDirectory()</strong></p>

<p><strong>Library/Caches:(跟Documents类似两种方法)</strong></p>

<p><strong>Library/Preference: 通过NSUserDefaults类获取该目下的设置信息</strong></p>

<h5>XML属性列表（plist）归档</h5>

<p>属性列表是一种XML格式的文件。扩展名为plist</p>

<p>如果对象是NSString、NSDictionary、NSArray、NSData、NSNumber等类型，就可以使用writeToFile:actomaiclly:方法直接将对象写到属性列表中。例如：</p>

<pre><code>// 将数据封装成字典
NSMutableDictionary *dict = [NSMutableDictionary dictionary];
[dict setObject:@"母鸡" forKey:@"name"];
[dict setObject:@"15013141314" forKey:@"phone"];
[dict setObject:@"27" forKey:@"age"];
// 将字典持久化到Documents/stu.plist文件中
[dict writeToFile:path atomically:YES];
</code></pre>

<p>读取属性列表：</p>

<pre><code>// 读取Documents/stu.plist的内容，实例化NSDictionary
NSDictionary *dict = [NSDictionary dictionaryWithContentsOfFile:path];
NSLog(@"name:%@", [dict objectForKey:@"name"]);
NSLog(@"phone:%@", [dict objectForKey:@"phone"]);
NSLog(@"age:%@", [dict objectForKey:@"age"]);
</code></pre>

<h5>Preference（偏好设置）</h5>

<ul>
<li>很多iOS应用都支持偏好设置，比如保存用户名、密码、字体大小等设置，iOS提供了一套标准的解决方案来为应用加入偏好设置功能</li>
<li>每个应用都有个NSUserDefaults实例，通过它来存取偏好设置</li>
<li>比如，保存用户名、字体大小、是否自动登录</li>
</ul>


<p>&mdash;</p>

<pre><code>NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
[defaults setObject:@"itcast" forKey:@"username"];
[defaults setFloat:18.0f forKey:@"text_size"];
[defaults setBool:YES forKey:@"auto_login"];
</code></pre>

<ul>
<li>读取上次保存的设置</li>
</ul>


<p>&mdash;</p>

<pre><code>NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
NSString *username = [defaults stringForKey:@"username"];
float textSize = [defaults floatForKey:@"text_size"];
BOOL autoLogin = [defaults boolForKey:@"auto_login"];
</code></pre>

<p><strong>注意</strong></p>

<p>UserDefaults设置数据时，不是立即写入，而是根据时间戳定时地把缓存中的的数据写入本地磁盘。所以调用了set方法之后数据有可能还没有写入磁盘应用程序就终止了。可以通过调用<code>synchornize</code>方法强制写入：</p>

<pre><code>[defaults synchornize];
</code></pre>

<h5>NSkeyedArchiver</h5>

<ul>
<li>如果对象是NSString、NSDictionary、NSArray、NSData、NSNumber等类型，可以直接用NSKeyedArchiver进行归档和恢复。</li>
<li>不是所有的对象都可以直接使用这种方法进行归档，只有遵守了NSCoding协议的对象才可以。</li>
</ul>


<p>NSCoding协议有两个方法:</p>

<p><strong>encodeWithCoder:</strong></p>

<p>每次归档对象时，都会调用这个方法。一般在这个方法里面指定如何归档对象中的实例变量，可以使用<code>encodeObject:forKey:</code>方法归档实例变量。</p>

<p><strong>initWithCoder</strong></p>

<p>每次从文件解码对象时，都会调用这个方法。一般在这个方法里面指定如何解码文件中的数据为对象的实例变量，可以使用<code>decodeObjectForKey:</code>方法解码实例变量。</p>

<p>示例：</p>

<pre><code>// 归档
Person *person = [[Person alloc] init];
person.name = @"Lily";
person.age = 27;
person.height = 1.83f;
[NSKeyedArchiver archiveRootObject:person toFile:path];

// 解码
Person *person = [NSKeyedUnarchiver unarchiveObjectWithFile:path];
</code></pre>

<p>对于Person.m文件:</p>

<pre><code>@implementation Person

- (void)encodeWithCoder:(NSCoder *)encoder {
    [encoder encodeObject:self.name forKey:@"name"];
    [encoder encodeInt:self.age forKey:@"age"];
    [encoder encodeFloat:self.height forKey:@"height"];
}
- (id)initWithCoder:(NSCoder *)decoder {
    self.name = [decoder decodeObjectForKey:@"name"];
    self.age = [decoder decodeIntForKey:@"age"];
    self.height = [decoder decodeFloatForKey:@"height"];
    return self;
}
@end
</code></pre>

<p><strong>NSKeyedArchiver归档对象注意:</strong></p>

<p>如果父类也遵守了NSCoding协议，应该在<code>encodeWithCoder:</code>方法加上一句<code>[super encodeWithCode:encode]</code>，确保继承的实例变量也能被编码，即也能被归档。应该在<code>initWithCoder:</code>方法加上:<code>self = [super initWithCoder:decoder]</code>确保集成的实例变量也能被解码。</p>

<h6>归档NSData</h6>

<p>使用<code>archiveRootObject:toFile:</code>方法可以将一个对象直接写入到一个文件中，但有时候可能想将多个对象写入到同一个文件中，那么就使用NSData来进行归档对象。</p>

<p>NSData可以为一些数据提供临时的存储空间，以便以后写入文件，或者存放从磁盘文件读取的内容。可以使用<code>[NSMutableData data]</code>创建可变数据空间。</p>

<p>示例：</p>

<pre><code>// 归档
// 新建一块可变数据区
NSMutableData *data = [NSMutableData data];
// 将数据区连接到一个NSKeyedArchiver对象
NSKeyedArchiver *archiver = [[[NSKeyedArchiver alloc] initForWritingWithMutableData:data] autorelease];
// 开始存档对象，存档的数据都会存储到NSMutableData中
[archiver encodeObject:person1 forKey:@"person1"];
[archiver encodeObject:person2 forKey:@"person2"];
// 存档完毕(一定要调用这个方法)
[archiver finishEncoding];
// 将存档的数据写入文件
[data writeToFile:path atomically:YES];

// 解码
// 从文件中读取数据
NSData *data = [NSData dataWithContentsOfFile:path];
// 根据数据，解析成一个NSKeyedUnarchiver对象
NSKeyedUnarchiver *unarchiver = [[NSKeyedUnarchiver alloc] initForReadingWithData:data];
Person *person1 = [unarchiver decodeObjectForKey:@"person1"];
Person *person2 = [unarchiver decodeObjectForKey:@"person2"];
// 恢复完毕
[unarchiver finishDecoding];
</code></pre>

<h5>利用归档可以实现深复制</h5>

<p>比如对一个Person对象进行深复制</p>

<pre><code>// 临时存储person1的数据
NSData *data = [NSKeyedArchiver archivedDataWithRootObject:person1];
// 解析data，生成一个新的Person对象
Student *person2 = [NSKeyedUnarchiver unarchiveObjectWithData:data];
// 分别打印内存地址
NSLog(@"person1:0x%x", person1); // person1:0x7177a60
NSLog(@"person2:0x%x", person2); // person2:0x7177cf0
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS中的多线程NSThread]]></title>
    <link href="http://conpgy.github.io/blog/2014/08/13/ios-thread/"/>
    <updated>2014-08-13T11:07:00+08:00</updated>
    <id>http://conpgy.github.io/blog/2014/08/13/ios-thread</id>
    <content type="html"><![CDATA[<p>ios中的实现方案，有下图所列出的这些：</p>

<p><img src="../../../../../pictures/thread.png" alt="" /></p>

<!--more-->


<h3>NSThread</h3>

<p>一个NSThread对象就代表一条线程。创建NSThread线程有三个方法。</p>

<pre><code>// 1.通过init创建，在调用start启动
NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];
[thread start];

// 2.创建线程后自动启动线程
[NSThread detachNewThreadSelector:@selector(run) toTarget:self withObject:nil];

// 3. 隐式创建并启动线程
[self performSelectorInBackground:@selector(run) withObject:nil];
</code></pre>

<p>主线程的相关方法有：</p>

<pre><code>(NSThread *)mainThread;     // 获得主线程
-(BOOL)isMainThread;        // 是否为主线程
+(BOOL)isMainThread;        // 是否为主线程
</code></pre>

<p>获得当前线程，可以调用<code>+currentThread</code>方法。</p>

<p>线程的调度优先级:</p>

<pre><code>+ (double)threadPriority;
+ (BOOL)setThreadPriority:(double)p;
</code></pre>

<p>调度优先级的取值范围是0.0~1.0，默认是0.5,值越大，优先级越高。</p>

<p>要访问或设置线程的名字,调用如下方法:</p>

<pre><code>- (void)setName:(NSString *)n;
- (NSString *)name;
</code></pre>

<h5>控制线程状态</h5>

<ul>
<li><p>启动线程</p>

<ul>
<li>(void)start;</li>
</ul>
</li>
<li><p>阻塞（暂停）线程</p>

<ul>
<li>(void)sleepUntilDate:(NSDate *)date;</li>
<li>(void)sleepForTimeInterval:(NSTimeInterval)ti;</li>
</ul>
</li>
<li><p>强制停止线程</p>

<ul>
<li>(void)exit;   // 进入死亡状态</li>
</ul>
</li>
</ul>


<p>一旦线程停止了，就不能再次开启任务。</p>

<h5>多线程的安全隐患</h5>

<p>1块资源可能会被多个线程共享，也就是多个线程可能会访问同一块资源,比如多个线程访问同一个对象、同一个变量、同一个文件,当多个线程访问同一块资源时，很容易引发数据错乱和数据安全问题。如下：</p>

<p><img src="../../../../../pictures/thread_safe.png" alt="" /></p>

<h5>互斥锁</h5>

<p>可以通过加锁解决多线程的安全问题。</p>

<pre><code>@synchronized(锁对象) { // 需要锁定的代码  }
</code></pre>

<p><strong>锁定一份代码只能加一把锁。</strong></p>

<p>互斥锁的优缺点</p>

<ul>
<li>优点：能有效防止因多线程抢夺资源造成的数据安全问题*</li>
<li>缺点：需要消耗大量的CPU资源</li>
</ul>


<p>使用互斥锁的前提是多线程抢夺统一块资源。</p>

<h5>原子和非原子属性</h5>

<p>OC在定义属性时有nonatomic和atomic两种选择</p>

<ul>
<li>atomic：原子属性，为setter方法加锁（默认就是atomic）</li>
<li>nonatomic：非原子属性，不会为setter方法加锁</li>
</ul>


<p><strong>atomic加锁原理：</strong></p>

<pre><code>@property (assign, atomic) int age;
- (void)setAge:(int)age
{
    @synchronized(self) {
        _age = age;
    }
}
</code></pre>

<p><strong>nonatomic和atomic对比</strong></p>

<ul>
<li>atomic：线程安全，需要消耗大量的资源</li>
<li>nonatomic：非线程安全，适合内存小的移动设备</li>
</ul>


<p><strong>iOS开发的建议</strong></p>

<ul>
<li>所有属性都声明为nonatomic</li>
<li>尽量避免多线程抢夺同一块资源</li>
<li>尽量将加锁、资源抢夺的业务逻辑交给服务器端处理，减小移动客户端的压力</li>
</ul>


<h5>线程间通信</h5>

<p>在1个进程中，线程往往不是孤立存在的，多个线程之间需要经常进行通信。线程间通信体现在：</p>

<ul>
<li>1个线程传递数据给另1个线程</li>
<li>在1个线程中执行完特定任务后，转到另1个线程继续执行任务</li>
</ul>


<p><strong>线程间通信常用方法</strong></p>

<pre><code>- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait;
- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[git基本使用]]></title>
    <link href="http://conpgy.github.io/blog/2014/08/02/git-brief-introduction/"/>
    <updated>2014-08-02T20:50:03+08:00</updated>
    <id>http://conpgy.github.io/blog/2014/08/02/git-brief-introduction</id>
    <content type="html"><![CDATA[<p><strong>git是Linux之父，Linus这个牛逼哄哄的大神发明的。本来别人以为，这位大神创建了Linux传奇已是人生巅峰了。而几十年后，这位牛人又创造了一个奇迹。常人难以望其项背。大神之所以成为大神，是因为他生来就是一位大神。</strong></p>

<h3>git和SVN的简单对比</h3>

<p><strong>速度</strong></p>

<ul>
<li>在很多情况下，git的速度远远比SVN快。</li>
</ul>


<p><strong>结构</strong></p>

<ul>
<li>SVN是集中式管理，git是分布式管理</li>
</ul>


<p><strong>其他</strong></p>

<ul>
<li>SVN使用比较笨拙，git轻松拥有无限个分支。</li>
<li>SVN必须联网才能工作，git支持本地版本控制。</li>
<li>就版本的SVN会在每个目录下放置一个.svn，git只会在根目录下有一个.git。</li>
</ul>


<p>分布式对别集中式的最大区别是：在分布式下，开发者可以在本地提交，每个开发者机器上都有一个服务器的数据库。</p>

<!-- more -->


<h3>git常用指令</h3>

<ul>
<li><p>git help: git指令帮助手册</p>

<blockquote><p>查看其他指令的做法: <code>git help 其他指令</code></p>

<p>配置用户名: <code>git config "user.name" 用户名</code></p>

<p>配置邮箱: <code>git config "user.email" 邮箱</code></p>

<p>查看配置信息: git config -l"</p>

<p>编辑配置信息: <code>git config -e</code></p>

<p>设置命令别名: <code>git config alias.别名 原指令名</code></p>

<p>设置带参数的别名: <code>git config alias.别名 "原指令名称 参数"</code></p>

<p>将此设置应用到整个系统中: <code>git config --global</code></p></blockquote></li>
<li><p>git status: 查看文件状态</p></li>
<li><p>git log: 查看文件的修改日志</p>

<blockquote><p>用一行的方式查看日志信息: git log &mdash;pretty=oneline
<strong>查看日志配置一个好用的方式</strong></p></blockquote>

<p>  git config &mdash;global alias.lg &ldquo;log &mdash;color &mdash;graph &mdash;pretty=format:&lsquo;%Cred%h%Creset &ndash;%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an>%Creset&rsquo; &mdash;abbrev-commit&rdquo;</p></li>
<li><p>git diff: 查看文件最新改动的状态</p></li>
<li><p>git init: 初始化一个空的本地仓库，生成一个.git目录，用于维护版本信息。</p></li>
<li>git add: 将<em>工作区</em>的文件保存到<em>暂缓区</em>

<blockquote><p>保存某个文件到暂缓区：git add 文件名</p>

<p>保存当前路径下的所有文件到暂缓区: git add .</p></blockquote></li>
<li>git commit: 将暂缓区的文件提交到当前分支。

<blockquote><p>提交某个文件到分支: <code>git commit -m "注释" 文件名</code></p>

<p>保存当前路径下的所有文件到分支: <code>git commit -m "注释"</code></p></blockquote></li>
<li>git reset: 版本回退(建议加上&mdash;hard参数，git支持无限次后悔)

<blockquote><p>回退到上一个版本: <code>git reset --hard HEAD^</code></p>

<p>回退到上上一个版本: <code>git reset --hard HEAD^^</code></p>

<p>回退到上N个版本: <code>git reset --hard HEAD~N</code></p>

<p>回退到任意一个版本: <code>git reset --hard 版本号</code></p></blockquote></li>
<li>git reflog: 查看指令使用记录（能够查看所有的版本号）</li>
<li><p>git rm: 删除文件（删除完之后要进行commit操作，才能同步到版本库）</p></li>
<li><p>git clone: 下载远程仓库到本地</p></li>
<li>git pull: 下载远程仓库的最新信息到本地仓库</li>
<li>git push: 将本地的仓库信息推送到远程仓库</li>
</ul>


<h3>工作原理</h3>

<p>要了解git的工作原理，必须要知道几个核心的概念:</p>

<p><strong>工作区(Working Directory)</strong>: 仓库文件夹里除.git目录以外的内容</p>

<p><strong>版本库(Repository)</strong>: .git目录，用于存储记录版本信息</p>

<ul>
<li><strong>暂缓区</strong></li>
<li><strong>分支（master）</strong>: git自动创建的第一个分支</li>
<li><strong>HEAD指针</strong>: 用于指向当前分支</li>
</ul>


<p><strong>git add和git commit的原理</strong></p>

<ul>
<li><code>git add .</code>: 把文件修改添加到暂存区</li>
<li><code>git commit:</code>: 把暂存区的所有内容提交到当前分支</li>
</ul>


<p><strong>工作原理图</strong></p>

<p><img src="../../../../../pictures/gitadd.png" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[svn基本使用]]></title>
    <link href="http://conpgy.github.io/blog/2014/08/02/svn-brief-introduction/"/>
    <updated>2014-08-02T20:14:20+08:00</updated>
    <id>http://conpgy.github.io/blog/2014/08/02/svn-brief-introduction</id>
    <content type="html"><![CDATA[<p><strong>基本操作</strong></p>

<p><img src="../../../../../pictures/svn.png" alt="" /></p>

<!-- more -->


<p>使用环境包含客户端和服务器环境。服务器用于存储客户端上传的源代码。Windows上可以使用Visual SVN Server。在Mac上，客户端可以使用Cornerstone这个软件进行代码的上传和同步等。</p>

<h3>SVN常用命令</h3>

<ul>
<li>svn checkout: 下载服务器的代码到本地（简写 svn co）</li>
<li>svn commit: 将改动的文件提交到服务器</li>
<li>svn update: 更新服务器的代码到本地（简写 svn up）</li>
<li>svn add: 向本地的版本控制库中添加新文件</li>
<li>svn delete 、svn remove: 从本地的版本库中删除文件（简写 svn del、svn rm）</li>
<li>svn move: 移动文件或者目录或文件改名</li>
<li>svn mkdir: 创建纳入版本控制下的新目录</li>
<li>svn revert: 撤销之前的一切修改</li>
<li>svn merge: 将两个版本之间的差异合并到当前文件</li>
<li>svn info: 查看文件的详细信息</li>
<li>svn diff: 查看不同版本的区别</li>
<li>svn log: 查看日志信息</li>
<li>svn list: 列出版本库下的文件或目录列表</li>
<li>svn status: 查看文件状态</li>
<li>svn help: 获取帮助信息</li>
<li>svn lock: 加锁</li>
<li>svn unlock: 解锁</li>
</ul>


<h3>常见问题</h3>

<p>不小心写错了很多东西，想撤销所有的操作（还没有修改提交到服务器）</p>

<pre><code>svn revert
</code></pre>

<p>不小心删错了文件，想把文件恢复过来（还未把删除提交到服务器）</p>

<pre><code>svn revert
</code></pre>

<p>不小心写错了很多东西，想撤销所有的操作（已经将修改提交到服务器）</p>

<pre><code>svn update -r 版本号
</code></pre>

<p>不小心删错了文件，想把文件恢复过来（已经将修改提交到服务器）</p>

<pre><code>svn update -r 版本号
</code></pre>

<p><strong>注意</strong> .svn这个目录记录着非常关键的信息，不要收工修改或删除这个目录和里面的文件。否则会导致本地的工作副本被破坏。无法再进行操作。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义瀑布流控件]]></title>
    <link href="http://conpgy.github.io/blog/2014/07/29/waterflowview/"/>
    <updated>2014-07-29T21:43:14+08:00</updated>
    <id>http://conpgy.github.io/blog/2014/07/29/waterflowview</id>
    <content type="html"><![CDATA[<p>在移动APP中，瀑布流越来越流行。本篇自定义一个简单的瀑布流控件。首先，模仿UITableView,定义一个数据源和代理协议。数据源协议有三个方法。如下：</p>

<pre><code>@protocol GYWaterflowViewDataSource &lt;NSObject&gt;

@required
/** 有多少条数据 */
-(NSUInteger)numberOfCellsInWaterflowView:(GYWaterflowView *)waterflowView;

/** index位置对应的cell */
-(GYWaterflowViewCell *)waterflowView:(GYWaterflowView *)waterflowView cellAtIndex:(NSUInteger)index;

@optional
/** 有多少列 */
-(NSUInteger)numberOfColumnsInWaterflowView:(GYWaterflowView *)waterflowView;

@end
</code></pre>

<!-- more -->


<p>然后，定义协议的方法，如下：</p>

<pre><code>@protocol GYWaterflowViewDelegate &lt;UIScrollViewDelegate&gt;

@optional
/** index位置cell的高度 */
-(CGFloat)waterflowView:(GYWaterflowView *)waterflowView heightAtIndex:(NSUInteger)index;

/** 选中index处的cell */
-(void)waterflowView:(GYWaterflowView *)waterflowView didSelectAtIndex:(NSUInteger)index;

/** 返回间距 */
-(CGFloat)waterflowView:(GYWaterflowView *)waterflowView marginForType:(GYWaterflowViewMarginType)type;

@end
</code></pre>

<p>这样，在控制器中我们就可以像使用tableView一样的轻松的使用这个瀑布流控件了。在控制器中，可以如下这样使用它。</p>

<pre><code>#import "GYViewController.h"
#import "GYWaterflowView.h"
#import "GYWaterflowViewCell.h"

@interface GYViewController ()&lt;GYWaterflowViewDataSource, GYWaterflowViewDelegate&gt;

@end

@implementation GYViewController

- (void)viewDidLoad
{
    [super viewDidLoad];

    // 添加一个瀑布流控件
    GYWaterflowView *waterflowView = [[GYWaterflowView alloc] init];
    waterflowView.frame = self.view.bounds;
    waterflowView.dataSource = self;
    waterflowView.delegate = self;
    [self.view addSubview:waterflowView];
}

#pragma mark - waterflowView dataSoure

-(NSUInteger)numberOfCellsInWaterflowView:(GYWaterflowView *)waterflowView
{
    return 100;
}

-(GYWaterflowViewCell *)waterflowView:(GYWaterflowView *)waterflowView cellAtIndex:(NSUInteger)index
{
    static NSString *identifier = @"waterflowViewCell";
    GYWaterflowViewCell *cell = [waterflowView dequeueReusableCellWithIdentifier:identifier];

    if (cell == nil) {
        cell = [[GYWaterflowViewCell alloc] init];
        cell.identifier = identifier;
    }
    cell.backgroundColor = GYRandomColor;

    return cell;
}

#pragma mark - waterflowView delegate

-(CGFloat)waterflowView:(GYWaterflowView *)waterflowView heightAtIndex:(NSUInteger)index
{
    return (arc4random_uniform(40) + 70);
}

@end
</code></pre>

<p>效果如下图：</p>

<p><img src="../../../../../pictures/waterflowView.png" alt="" /></p>

<p>接下来，是如何实现<code>GYWaterflowView</code>。模仿tableView，定义一个<code>reloadData</code>方法，当调用这个方法时，会刷新里面的所有子控件。我们定义一个<code>GYWaterflowViewCell</code>作为它的子控件。在这个cell类中，提供一个<code>identifier</code>属性用来标识cell。在<code>reloadData</code>方法中，需要重新计算所有的cell的frame。然后在<code>layoutSubView</code>方法中将在屏幕上的cell显示出来。<code>reloadData</code>方法的具体实现如下：</p>

<pre><code>-(void)reloadData
{
    // 清空之前的数据
    [self.displayingCells.allValues makeObjectsPerformSelector:@selector(removeFromSuperview)];
    [self.displayingCells removeAllObjects];
    [self.cellFrames removeAllObjects];
    [self.reuseableCells removeAllObjects];

    // 数据总条数
    NSUInteger numberOfCells = [self.dataSource numberOfCellsInWaterflowView:self];

    // 总列数
    NSUInteger numberOfColumns = [self numberOfColumns];

    // 间距
    CGFloat topM = [self marginForType:GYWaterflowViewMarginTypeTop];
    CGFloat leftM = [self marginForType:GYWaterflowViewMarginTypeLeft];
    CGFloat rowM = [self marginForType:GYWaterflowViewMarginTypeRow];
    CGFloat columnM = [self marginForType:GYWaterflowViewMarginTypeColumn];
    CGFloat bottomM = [self marginForType:GYWaterflowViewMarginTypeBottom];

    // 计算cell的宽度
    CGFloat cellW = [self cellWidth];

    // 用一个C语言数组存放所有列的最大y值
    CGFloat maxYOfColumns[numberOfColumns];
    // 初始化
    for (int i = 0; i &lt; numberOfColumns; i++) {
        maxYOfColumns[i] = 0.0;
    }

    // 计算所有cell的frame
    for (int i = 0; i &lt; numberOfCells; i++) {
        // cell处在第几列
        NSUInteger cellColumn = 0;

        // cell所处那列的最大Y值(最短那一列的最大Y值)
        CGFloat cellMaxYOfColumn = maxYOfColumns[cellColumn];
        // 求出最短的一列
        for (int j = 1; j&lt;numberOfColumns; j++) {
            if (maxYOfColumns[j] &lt; cellMaxYOfColumn) {
                cellColumn = j;
                cellMaxYOfColumn = maxYOfColumns[j];
            }
        }

        // 计算出cell的位置
        CGFloat cellX = leftM + (cellW + columnM) * cellColumn;
        CGFloat cellY = 0;
        if (cellMaxYOfColumn == 0.0) {   // cell处在第一行
            cellY = topM;
        } else {
            cellY = cellMaxYOfColumn + rowM;
        }

        // cell的高度
        CGFloat cellH = [self heightAtIndex:i];

        // 计算出cell的frame
        CGRect cellFrame = CGRectMake(cellX, cellY, cellW, cellH);

        // 将cell的frame添加到数组中
        [self.cellFrames addObject:[NSValue valueWithCGRect:cellFrame]];

        // 更新cell所处列的最大y值
        maxYOfColumns[cellColumn] = CGRectGetMaxY(cellFrame);
    }

    // 设置contentSize
    CGFloat contentH = maxYOfColumns[0];
    for (int i = 1; i &lt; numberOfColumns; i++) {
        if (maxYOfColumns[i] &gt; contentH) {
            contentH = maxYOfColumns[i];
        }
    }
    contentH += bottomM;
    self.contentSize = CGSizeMake(0, contentH);

}
</code></pre>

<p>这样，每个cell的的frame都计算出来了，并保存在cellFrames数组中。也计算出来了waterflowView的contentSize。然后就可以在<code>layoutSubView</code>中，将在屏幕上的cell显示出来。<code>layoutSubViews</code>具体实现如下：</p>

<pre><code>-(void)layoutSubviews
{
    [super layoutSubviews];

    // cell总数
    NSUInteger numberOfCells = self.cellFrames.count;

    for (int i = 0; i &lt; numberOfCells; i++) {
        // 取出i位置的cellFrame
        CGRect cellFrame = [self.cellFrames[i] CGRectValue];

        // 从字典中取出i位置的cell
        GYWaterflowViewCell *cell = self.displayingCells[@(i)];

        // 判断cellFrame在不在屏幕上
        if ([self isInScreen:cellFrame]) {
            if (cell == nil) {
                cell = [self.dataSource waterflowView:self cellAtIndex:i];
                cell.frame = cellFrame;
                [self addSubview:cell];

                // 存放到字典中
                self.displayingCells[@(i)] = cell;
            }
        } else {
            if (cell) {
                // 从scrollView和displayingCells字典中删除
                [cell removeFromSuperview];
                [self.displayingCells removeObjectForKey:@(i)];

                // 存放到缓存池中
                [self.reuseableCells addObject:cell];
            }
        }
    }
}
</code></pre>

<p>通过每个cell的frame，计算这个cell是否在屏幕上，如果不是，则不显示，并且，如果这个cell刚从屏幕上移除，那么将它从<code>waterflowView</code>上移除，并且从正在显示的cell的字典中删除，然后放入缓存池中。如果cell的frame在屏幕范围内，那么需要判断这个cell在滚动之前是否已经在屏幕上了，如果在，则什么也不做，如果不在，则从数据源方法中获得这个cell并且添加到<code>waterflowView</code>中。<code>isInScreen:</code>方法实现如下：</p>

<pre><code>/**
 *  判断cell的frame是否显示在屏幕上
 */
- (BOOL)isInScreen:(CGRect)frame
{
    return ((CGRectGetMaxY(frame) &gt; self.contentOffset.y) &amp;&amp; (CGRectGetMinY(frame) &lt; self.contentOffset.y + self.bounds.size.height));
}
</code></pre>

<p>还有一个注意点是，当瀑布流控件添加到控制器的view中时，需要显示这个控件的内容，因此我们可以在<code>willMoveToSuperView:</code>方法中调用<code>reloadData</code>方法，让它一添加就进行显示。</p>

<p>还有一个注意点是，我们提供了cell的复用机制，<code>- (id)dequeueReusableCellWithIdentifier:(NSString *)identifier</code>的实现如下：</p>

<pre><code>-(id)dequeueReusableCellWithIdentifier:(NSString *)identifier
{
    __block GYWaterflowViewCell *reuseableCell = nil;

    [self.reuseableCells enumerateObjectsUsingBlock:^(GYWaterflowViewCell *cell, BOOL *stop) {
        if ([cell.identifier isEqualToString:identifier]) {
            reuseableCell = cell;
            *stop = YES;
        }
    }];

    if (reuseableCell) {
        [self.reuseableCells removeObject:reuseableCell];
    }

    return reuseableCell;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
