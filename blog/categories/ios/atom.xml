<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | 无着的博客]]></title>
  <link href="http://conpgy.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://conpgy.github.io/"/>
  <updated>2014-07-25T08:38:54+08:00</updated>
  <id>http://conpgy.github.io/</id>
  <author>
    <name><![CDATA[无着]]></name>
    <email><![CDATA[conpgy@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[属性文本的截取与事件处理]]></title>
    <link href="http://conpgy.github.io/blog/2014/07/24/attributedstring-event/"/>
    <updated>2014-07-24T18:57:49+08:00</updated>
    <id>http://conpgy.github.io/blog/2014/07/24/attributedstring-event</id>
    <content type="html"><![CDATA[<p>上一篇<a href="http://conpgy.github.io/blog/2014/07/20/weibo-emotion-text/">实现新浪微博图文混排</a>谈到了表情与文本的混合排列。属性文本可以有效的设置一段文本中的文字可以有不同的属性。比方微博文本中有话题，超链接，@某人等等。对这些文本需要进行高亮和事件处理。跳转到相应的微博或者链接等等。要实现这个功能，可以分成四个步骤：</p>

<ol>
<li>查找出所有的链接（用一个数组存放所有的链接）</li>
<li>在touchesBegan方法中，根据触摸点找出被点击的的链接。</li>
<li>在被点击的链接的边框范围内添加高亮背景</li>
<li>在touchesEnd中，移除高亮背景。并发出通知，通知相应的控制器进行事件处理。</li>
</ol>


<!-- more -->


<p>查看完整代码，请猛击<a href="http://github.com/conpgy">这里</a>。</p>

<h4>查找出所有的链接</h4>

<p>通过遍历属性文本，找出对应的链接。然后用一个<code>GYLink</code>模型保存起来。模型总有三个属性：</p>

<pre><code>/** 链接文字 */
@property (nonatomic, copy) NSString *text;

/** 链接范围 */
@property (nonatomic, assign) NSRange range;

/** 链接边框 */
@property (nonatomic, strong) NSArray *rects;
</code></pre>

<p>然后将所有的链接保存在一个数组中。代码如下：</p>

<pre><code>-(NSMutableArray *)links
{
    if (!_links) {
        NSMutableArray *links = [NSMutableArray array];

        // 搜索所有的链接
        [self.attributedText enumerateAttribute:GYLinkText inRange:NSMakeRange(0, self.attributedText.length) options:0 usingBlock:^(id value, NSRange range, BOOL *stop) {

            if (value == nil) return;

            GYLink *link = [[GYLink alloc] init];
            link.text = value;
            link.range = range;

            // 处理矩形框
            NSMutableArray *rects = [NSMutableArray array];
            // 设置字符选中的范围
            self.textView.selectedRange = range;
            // 计算选中字符范围的边框
            NSArray *selectionRects = [self.textView selectionRectsForRange:self.textView.selectedTextRange];
            for (UITextSelectionRect *selectionRect in selectionRects) {
                if (selectionRect.rect.size.width == 0 || selectionRect.rect.size.height == 0) continue;

                [rects addObject:selectionRect];
            }
            link.rects = rects;

            [links addObject:link];
        }];
        _links = links;
    }

    return _links;
}
</code></pre>

<p>这里，取出链接在属性文本中的范围，设置为textView的选中范围。然后会自动计算出textView中文本字符的范围。根据计算出边框，放在数组中<code>selectionRects</code>,然后保存到<code>link</code>对象的rects中。这样链接的文本边框就被保存起来了。接下来当点击链接的时候就可以高亮链接的边框了。</p>

<h4>在touchesBegan方法中，根据触摸点找出被点击的的链接。</h4>

<p>在touchesBegan方法中，根据被触摸的点计算出哪个链接被点击了。</p>

<pre><code>__block GYLink *touchingLink = nil;

[self.links enumerateObjectsUsingBlock:^(GYLink *link, NSUInteger idx, BOOL *stop) {
    for (UITextSelectionRect *selectionRect in link.rects) {
        if (CGRectContainsPoint(selectionRect.rect, point)) {
            touchingLink = link;
            break;
        }
    }
}];
</code></pre>

<p>这样，被点击的链接<code>touchingLink</code>就计算出来了。然后，高亮选中的链接边框。</p>

<h4>在被点击的链接的边框范围内添加高亮背景</h4>

<p>通过一个for循环，遍历的得到链接字符串所在的边框范围。</p>

<pre><code>for (UITextSelectionRect *selectionRect in link.rects) {
    UIView *view = [[UIView alloc] init];
    view.tag = GYLinkBackgroundTag;
    view.alpha = 0.5;
    view.layer.cornerRadius = 3;

    view.frame = selectionRect.rect;

    [self insertSubview:view atIndex:0];
    view.backgroundColor = GYColor(83, 148, 255);
}
</code></pre>

<p>然后在<code>touchCancelled</code>和<code>touchEnded</code>方法中将高亮的背景view给删除。</p>

<pre><code>dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.25 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
    for (UIView *view in self.subviews) {
        if (view.tag == GYLinkBackgroundTag) {
            [view removeFromSuperview];
        }
    }
});
</code></pre>

<p>为了能够获得这个背景view，前面给这个view添加了一个tag。最后，发送一个通知给控制器，让控制器决定链接点击事件进行处理。做出相应的跳转。</p>

<pre><code>    [[NSNotificationCenter defaultCenter] postNotificationName:GYLinkDidSelectedNotification object:nil userInfo:@{GYLinkText: touchingLink.text}];
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[实现新浪微博图文混排效果]]></title>
    <link href="http://conpgy.github.io/blog/2014/07/20/weibo-emotion-text/"/>
    <updated>2014-07-20T11:29:05+08:00</updated>
    <id>http://conpgy.github.io/blog/2014/07/20/weibo-emotion-text</id>
    <content type="html"><![CDATA[<p>通常，我们都会有图片和文字混合起来展示的需求。像杂志中展示一篇文章。QQ发送带表情文字的信息。微博的展示等等&hellip; 这里，我们简单的实现一下表情和文字的混合显示。模仿新浪微博，实现效果如下图：</p>

<p><img src="../../../../../pictures/weibo.png" alt="" /></p>

<p>我分为三大步骤：</p>

<ol>
<li>将表情插入到编辑框中</li>
<li>将带有表情的富文本转换为带有表情描述的普通文本，并发送给服务器</li>
<li>从服务器接收带有表情描述的普通文本，将表情描述解析成对应的表情</li>
</ol>


<!-- more -->


<p>查看完整代码，请点击<a href="https://github.com/conpgy/weibo-emotion-text/tree/emtionAndText">这里</a></p>

<h3>将表情插入到编辑框</h3>

<p>微博编辑框我们使用<code>GYEmotionTextView</code>，它继承自<code>GYTextView</code>, GYTextView继承自<code>UITextView</code>。<code>GYTextView</code>主要是增加了一个占位文字的功能。我们给<code>GYEmotionTextView</code>增加一个添加表情的方法<code>appendEmotion:</code>。具体实现如下：</p>

<pre><code>// GYEmotionTextView.m
/**
 *  在微博编辑框添加表情时调用
 *
 *  @param emotion 添加的表情
 */
-(void)appendEmotion:(GYEmotion *)emotion
{
    if (emotion.code) { // Emoji表情
    [self insertText:emotion.emoji];
    } else { // 图片表情
        NSMutableAttributedString *attributeText = [[NSMutableAttributedString alloc] initWithAttributedString:self.attributedText];


        // 创建一个带有图片表情的富文本
        GYEmotionAttachment *attachment = [[GYEmotionAttachment alloc] init];
        attachment.emotion = emotion;
        NSString *name = [NSString stringWithFormat:@"%@/%@", emotion.directory, emotion.png];
        attachment.image = [UIImage imageWithName:name];
        attachment.bounds = CGRectMake(0, -3, self.font.lineHeight, self.font.lineHeight);
        NSAttributedString *emotionStr = [NSMutableAttributedString attributedStringWithAttachment: attachment];

        // 记录表情的插入位置
        int insertIndex = self.selectedRange.location;
        // 插入表情到光标所在的位置
        [attributeText insertAttributedString:emotionStr atIndex:insertIndex];

        // 设置字体
        [attributeText addAttribute:NSFontAttributeName value:self.font range:NSMakeRange(0, attributeText.length)];

        self.attributedText = attributeText;

        // 让光标回到新插入表情的后面
        self.selectedRange = NSMakeRange(insertIndex + 1, 0);
    }

}
</code></pre>

<p>当我们从表情键盘选中一个表情时，就会在微博编辑框的光标位置插入对应的表情。<code>GYEmotionAttachment</code>集成自<code>NSTextAttachment</code>，<code>NSTextAttachment</code>是iOS7新增的类，有了它，就可以很方便的操控富文本了。这样，我们就可以对微博进行编辑了，效果如下：</p>

<p><img src="../../../../../pictures/send.png" alt="" /></p>

<p>当完成编辑后，就可以发送微博了。但是发送给服务器的一般都是普通的文本。因此，我们就不能这样发送了，需要将这个富文本，转换为普通的文本。</p>

<h3>将带有表情的富文本转换为带有表情描述的普通文本，并发送给服务器</h3>

<p>如何将富文本转换为普通文本呢？<code>NSAttributedString.h</code>有一个对象方法<code>- (void)enumerateAttributesInRange:(NSRange)enumerationRange options:(NSAttributedStringEnumerationOptions)opts usingBlock:(void (^)(NSDictionary *attrs, NSRange range, BOOL *stop))block</code>， 有了它，我们可以对富文本进行遍历，它会自动对这个文本进行切割，将普通文本和文本附件分离出来，通过block传递给我们,我们就可以通过字典<code>attrs</code>，通过关键字<code>NSAttachment</code>判断是否是表情。如下：</p>

<pre><code>NSMutableString *string = [NSMutableString string];

// 获得微博编辑框的富文本
NSAttributedString *attributeText = self.attributedText;

// 遍历富文本，将表情转换为文字描述
[attributeText enumerateAttributesInRange:NSMakeRange(0, self.attributedText.length) options:0 usingBlock:^(NSDictionary *attrs, NSRange range, BOOL *stop) {
    GYEmotionAttachment *attachment = attrs[@"NSAttachment"];
    if (attachment) {   //有表情
        [string appendString:attachment.emotion.chs];
    } else {    // 没有表情
        // 根据range范围获得富文本的文字内容
        NSString *subStr = [attributeText attributedSubstringFromRange:range].string;
        [string appendString:subStr];
    }
}];
</code></pre>

<p>这样我们就得到了带有表情描述的普通文本<code>string</code>，可以将它发送给服务器了。需要注意的是<code>GYEmotionAttachment</code>是我们自定义的，它继承自<code>NSTextAttachment</code>，给它添加一个属性emotion，就可以非常方便的获得传递过来的表情是哪个，然后找到对应的文字描述，进行字符串拼接。</p>

<h3>从服务器接收带有表情描述的普通文本，将表情描述解析成对应的表情</h3>

<p>我们其实就已经完成发送微博的功能了，可以该干嘛干嘛了。好好Happy一下了。OK，happy完后，如果我们需要浏览浏览别人的微博，就要向新浪的服务器发送请求，然后新浪将微博数据发送给我们，好，和发微博一样，服务器给客户端发送的数据一般也是文本。是没有表情的。因此，在客户端，我们需要对文本进行解析，转换成带有表情的微博。OK，世界瞬间又成了彩色的了。不过，这里，就比刚才稍显复杂了。要对文本进行解析，首先需要知道该怎么解析，解析成什么。像表情，一般是通过比如这样<code>[哈哈]</code>进行描述的。因此，我们需要对这样的文本进行查找，并替换。我们使用正在表达式，并使用第三方框架<code>RegexKitLite</code>。对文本进行匹配，将每一段普通文本和表情描述保存在数组<code>results</code>中，然后对数组进行排序。如下：</p>

<pre><code>/**
 *  根据文本计算出匹配结果
 *
 *  @param text 文本
 *
 *  @return 匹配结果数组
 */
- (NSArray *)regexResultsWithText:(NSString *)text
{
    // 存储匹配结果
    NSMutableArray *results = [NSMutableArray array];

    // 设置表情匹配格式
    NSString *emotionRegex = @"\\[[a-zA-Z0-9\\u4e00-\\u9fa5]+\\]";

    //遍历文本，根据表情格式匹配表情
    [text enumerateStringsMatchedByRegex:emotionRegex usingBlock:^(NSInteger captureCount, NSString *const __unsafe_unretained *capturedStrings, const NSRange *capturedRanges, volatile BOOL *const stop) {

        GYRegexResult *regexR = [[GYRegexResult alloc] init];
        regexR.string = *capturedStrings;
        regexR.range = *capturedRanges;
        regexR.emotion = YES;

        [results addObject:regexR];
    }];

    //遍历文本，根据表情格式匹配非表情
    [text enumerateStringsSeparatedByRegex:emotionRegex usingBlock:^(NSInteger captureCount, NSString *const __unsafe_unretained *capturedStrings, const NSRange *capturedRanges, volatile BOOL *const stop) {

        GYRegexResult *regexR = [[GYRegexResult alloc] init];
        regexR.string = *capturedStrings;
        regexR.range = *capturedRanges;
        regexR.emotion = NO;

        [results addObject:regexR];
    }];

    // 对匹配结果进行排序,(根据range的location，从小到大)
    [results sortUsingComparator:^NSComparisonResult(GYRegexResult *r1, GYRegexResult *r2) {
        int loc1 = r1.range.location;
        int loc2 = r2.range.location;

        return [@(loc1) compare:@(loc2)];
    }];

    return results;
}
</code></pre>

<p>得到这个数组后，就可以进行富文本的拼接了。如下：</p>

<pre><code>/**
 *  将带有表情描述的普通文本转换为富文本
 */
- (NSAttributedString *)attributeTextWithText:(NSString *)text
{
    NSMutableAttributedString *attributeText = [[NSMutableAttributedString alloc] init];

    // 根据本文计算出匹配结果
    NSArray *regexResults = [self regexResultsWithText:text];

    // 根据匹配结果拼接文本
    [regexResults enumerateObjectsUsingBlock:^(GYRegexResult *regexResult, NSUInteger idx, BOOL *stop) {
        if (regexResult.isEmotion) {    // 表情
            GYEmotionAttachment *attachment = [[GYEmotionAttachment alloc] init];
            attachment.emotion = [GYEmotionTool emotionWithDesc:regexResult.string];
            attachment.bounds = CGRectMake(0, -3, GYStatusTextFont.lineHeight, GYStatusTextFont.lineHeight);
            NSAttributedString *subStr = [NSAttributedString attributedStringWithAttachment:attachment];

            [attributeText appendAttributedString:subStr];
        } else {    // 非表情, 普通文本
            NSMutableAttributedString *subStr = [[NSMutableAttributedString alloc] initWithString:regexResult.string];

            [attributeText appendAttributedString:subStr];
        }
    }];


    // 设置字体
    [attributeText addAttribute:NSFontAttributeName value:GYStatusTextFont range:NSMakeRange(0, attributeText.length)];

    return attributeText;
}
</code></pre>

<p>这样，得到了富文本<code>attributeText</code>，好了，就可以直接进行展示了。如下图：</p>

<p><img src="../../../../../pictures/display.png" alt="" /></p>
]]></content>
  </entry>
  
</feed>
