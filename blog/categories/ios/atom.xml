<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | 无着的博客]]></title>
  <link href="http://conpgy.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://conpgy.github.io/"/>
  <updated>2014-07-29T22:51:44+08:00</updated>
  <id>http://conpgy.github.io/</id>
  <author>
    <name><![CDATA[无着]]></name>
    <email><![CDATA[conpgy@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[自定义瀑布流控件]]></title>
    <link href="http://conpgy.github.io/blog/2014/07/29/waterflowview/"/>
    <updated>2014-07-29T21:43:14+08:00</updated>
    <id>http://conpgy.github.io/blog/2014/07/29/waterflowview</id>
    <content type="html"><![CDATA[<p>在移动APP中，瀑布流越来越流行。本篇自定义一个简单的瀑布流控件。首先，模仿UITableView,定义一个数据源和代理协议。数据源协议有三个方法。如下：</p>

<pre><code>@protocol GYWaterflowViewDataSource &lt;NSObject&gt;

@required
/** 有多少条数据 */
-(NSUInteger)numberOfCellsInWaterflowView:(GYWaterflowView *)waterflowView;

/** index位置对应的cell */
-(GYWaterflowViewCell *)waterflowView:(GYWaterflowView *)waterflowView cellAtIndex:(NSUInteger)index;

@optional
/** 有多少列 */
-(NSUInteger)numberOfColumnsInWaterflowView:(GYWaterflowView *)waterflowView;

@end
</code></pre>

<!-- more -->


<p>然后，定义协议的方法，如下：</p>

<pre><code>@protocol GYWaterflowViewDelegate &lt;UIScrollViewDelegate&gt;

@optional
/** index位置cell的高度 */
-(CGFloat)waterflowView:(GYWaterflowView *)waterflowView heightAtIndex:(NSUInteger)index;

/** 选中index处的cell */
-(void)waterflowView:(GYWaterflowView *)waterflowView didSelectAtIndex:(NSUInteger)index;

/** 返回间距 */
-(CGFloat)waterflowView:(GYWaterflowView *)waterflowView marginForType:(GYWaterflowViewMarginType)type;

@end
</code></pre>

<p>这样，在控制器中我们就可以像使用tableView一样的轻松的使用这个瀑布流控件了。在控制器中，可以如下这样使用它。</p>

<pre><code>#import "GYViewController.h"
#import "GYWaterflowView.h"
#import "GYWaterflowViewCell.h"

@interface GYViewController ()&lt;GYWaterflowViewDataSource, GYWaterflowViewDelegate&gt;

@end

@implementation GYViewController

- (void)viewDidLoad
{
    [super viewDidLoad];

    // 添加一个瀑布流控件
    GYWaterflowView *waterflowView = [[GYWaterflowView alloc] init];
    waterflowView.frame = self.view.bounds;
    waterflowView.dataSource = self;
    waterflowView.delegate = self;
    [self.view addSubview:waterflowView];
}

#pragma mark - waterflowView dataSoure

-(NSUInteger)numberOfCellsInWaterflowView:(GYWaterflowView *)waterflowView
{
    return 100;
}

-(GYWaterflowViewCell *)waterflowView:(GYWaterflowView *)waterflowView cellAtIndex:(NSUInteger)index
{
    static NSString *identifier = @"waterflowViewCell";
    GYWaterflowViewCell *cell = [waterflowView dequeueReusableCellWithIdentifier:identifier];

    if (cell == nil) {
        cell = [[GYWaterflowViewCell alloc] init];
        cell.identifier = identifier;
    }
    cell.backgroundColor = GYRandomColor;

    return cell;
}

#pragma mark - waterflowView delegate

-(CGFloat)waterflowView:(GYWaterflowView *)waterflowView heightAtIndex:(NSUInteger)index
{
    return (arc4random_uniform(40) + 70);
}

@end
</code></pre>

<p>效果如下图：</p>

<p><img src="../../../../../pictures/waterflowView.png" alt="" /></p>

<p>接下来，是如何实现<code>GYWaterflowView</code>。模仿tableView，定义一个<code>reloadData</code>方法，当调用这个方法时，会刷新里面的所有子控件。我们定义一个<code>GYWaterflowViewCell</code>作为它的子控件。在这个cell类中，提供一个<code>identifier</code>属性用来标识cell。在<code>reloadData</code>方法中，需要重新计算所有的cell的frame。然后在<code>layoutSubView</code>方法中将在屏幕上的cell显示出来。<code>reloadData</code>方法的具体实现如下：</p>

<pre><code>-(void)reloadData
{
    // 清空之前的数据
    [self.displayingCells.allValues makeObjectsPerformSelector:@selector(removeFromSuperview)];
    [self.displayingCells removeAllObjects];
    [self.cellFrames removeAllObjects];
    [self.reuseableCells removeAllObjects];

    // 数据总条数
    NSUInteger numberOfCells = [self.dataSource numberOfCellsInWaterflowView:self];

    // 总列数
    NSUInteger numberOfColumns = [self numberOfColumns];

    // 间距
    CGFloat topM = [self marginForType:GYWaterflowViewMarginTypeTop];
    CGFloat leftM = [self marginForType:GYWaterflowViewMarginTypeLeft];
    CGFloat rowM = [self marginForType:GYWaterflowViewMarginTypeRow];
    CGFloat columnM = [self marginForType:GYWaterflowViewMarginTypeColumn];
    CGFloat bottomM = [self marginForType:GYWaterflowViewMarginTypeBottom];

    // 计算cell的宽度
    CGFloat cellW = [self cellWidth];

    // 用一个C语言数组存放所有列的最大y值
    CGFloat maxYOfColumns[numberOfColumns];
    // 初始化
    for (int i = 0; i &lt; numberOfColumns; i++) {
        maxYOfColumns[i] = 0.0;
    }

    // 计算所有cell的frame
    for (int i = 0; i &lt; numberOfCells; i++) {
        // cell处在第几列
        NSUInteger cellColumn = 0;

        // cell所处那列的最大Y值(最短那一列的最大Y值)
        CGFloat cellMaxYOfColumn = maxYOfColumns[cellColumn];
        // 求出最短的一列
        for (int j = 1; j&lt;numberOfColumns; j++) {
            if (maxYOfColumns[j] &lt; cellMaxYOfColumn) {
                cellColumn = j;
                cellMaxYOfColumn = maxYOfColumns[j];
            }
        }

        // 计算出cell的位置
        CGFloat cellX = leftM + (cellW + columnM) * cellColumn;
        CGFloat cellY = 0;
        if (cellMaxYOfColumn == 0.0) {   // cell处在第一行
            cellY = topM;
        } else {
            cellY = cellMaxYOfColumn + rowM;
        }

        // cell的高度
        CGFloat cellH = [self heightAtIndex:i];

        // 计算出cell的frame
        CGRect cellFrame = CGRectMake(cellX, cellY, cellW, cellH);

        // 将cell的frame添加到数组中
        [self.cellFrames addObject:[NSValue valueWithCGRect:cellFrame]];

        // 更新cell所处列的最大y值
        maxYOfColumns[cellColumn] = CGRectGetMaxY(cellFrame);
    }

    // 设置contentSize
    CGFloat contentH = maxYOfColumns[0];
    for (int i = 1; i &lt; numberOfColumns; i++) {
        if (maxYOfColumns[i] &gt; contentH) {
            contentH = maxYOfColumns[i];
        }
    }
    contentH += bottomM;
    self.contentSize = CGSizeMake(0, contentH);

}
</code></pre>

<p>这样，每个cell的的frame都计算出来了，并保存在cellFrames数组中。也计算出来了waterflowView的contentSize。然后就可以在<code>layoutSubView</code>中，将在屏幕上的cell显示出来。<code>layoutSubViews</code>具体实现如下：</p>

<pre><code>-(void)layoutSubviews
{
    [super layoutSubviews];

    // cell总数
    NSUInteger numberOfCells = self.cellFrames.count;

    for (int i = 0; i &lt; numberOfCells; i++) {
        // 取出i位置的cellFrame
        CGRect cellFrame = [self.cellFrames[i] CGRectValue];

        // 从字典中取出i位置的cell
        GYWaterflowViewCell *cell = self.displayingCells[@(i)];

        // 判断cellFrame在不在屏幕上
        if ([self isInScreen:cellFrame]) {
            if (cell == nil) {
                cell = [self.dataSource waterflowView:self cellAtIndex:i];
                cell.frame = cellFrame;
                [self addSubview:cell];

                // 存放到字典中
                self.displayingCells[@(i)] = cell;
            }
        } else {
            if (cell) {
                // 从scrollView和displayingCells字典中删除
                [cell removeFromSuperview];
                [self.displayingCells removeObjectForKey:@(i)];

                // 存放到缓存池中
                [self.reuseableCells addObject:cell];
            }
        }
    }
}
</code></pre>

<p>通过每个cell的frame，计算这个cell是否在屏幕上，如果不是，则不显示，并且，如果这个cell刚从屏幕上移除，那么将它从<code>waterflowView</code>上移除，并且从正在显示的cell的字典中删除，然后放入缓存池中。如果cell的frame在屏幕范围内，那么需要判断这个cell在滚动之前是否已经在屏幕上了，如果在，则什么也不做，如果不在，则从数据源方法中获得这个cell并且添加到<code>waterflowView</code>中。<code>isInScreen:</code>方法实现如下：</p>

<pre><code>/**
 *  判断cell的frame是否显示在屏幕上
 */
- (BOOL)isInScreen:(CGRect)frame
{
    return ((CGRectGetMaxY(frame) &gt; self.contentOffset.y) &amp;&amp; (CGRectGetMinY(frame) &lt; self.contentOffset.y + self.bounds.size.height));
}
</code></pre>

<p>还有一个注意点是，当瀑布流控件添加到控制器的view中时，需要显示这个控件的内容，因此我们可以在<code>willMoveToSuperView:</code>方法中调用<code>reloadData</code>方法，让它一添加就进行显示。</p>

<p>还有一个注意点是，我们提供了cell的复用机制，<code>- (id)dequeueReusableCellWithIdentifier:(NSString *)identifier</code>的实现如下：</p>

<pre><code>-(id)dequeueReusableCellWithIdentifier:(NSString *)identifier
{
    __block GYWaterflowViewCell *reuseableCell = nil;

    [self.reuseableCells enumerateObjectsUsingBlock:^(GYWaterflowViewCell *cell, BOOL *stop) {
        if ([cell.identifier isEqualToString:identifier]) {
            reuseableCell = cell;
            *stop = YES;
        }
    }];

    if (reuseableCell) {
        [self.reuseableCells removeObject:reuseableCell];
    }

    return reuseableCell;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[属性文本的截取与事件处理]]></title>
    <link href="http://conpgy.github.io/blog/2014/07/24/attributedstring-event/"/>
    <updated>2014-07-24T18:57:49+08:00</updated>
    <id>http://conpgy.github.io/blog/2014/07/24/attributedstring-event</id>
    <content type="html"><![CDATA[<p>上一篇<a href="http://conpgy.github.io/blog/2014/07/20/weibo-emotion-text/">实现新浪微博图文混排</a>谈到了表情与文本的混合排列。属性文本可以有效的设置一段文本中的文字可以有不同的属性。比方微博文本中有话题，超链接，@某人等等。对这些文本需要进行高亮和事件处理。跳转到相应的微博或者链接等等。要实现这个功能，可以分成四个步骤：</p>

<ol>
<li>查找出所有的链接（用一个数组存放所有的链接）</li>
<li>在touchesBegan方法中，根据触摸点找出被点击的的链接。</li>
<li>在被点击的链接的边框范围内添加高亮背景</li>
<li>在touchesEnd中，移除高亮背景。并发出通知，通知相应的控制器进行事件处理。</li>
</ol>


<!-- more -->


<p>查看完整代码，请猛击<a href="http://github.com/conpgy">这里</a>。</p>

<h4>查找出所有的链接</h4>

<p>通过遍历属性文本，找出对应的链接。然后用一个<code>GYLink</code>模型保存起来。模型总有三个属性：</p>

<pre><code>/** 链接文字 */
@property (nonatomic, copy) NSString *text;

/** 链接范围 */
@property (nonatomic, assign) NSRange range;

/** 链接边框 */
@property (nonatomic, strong) NSArray *rects;
</code></pre>

<p>然后将所有的链接保存在一个数组中。代码如下：</p>

<pre><code>-(NSMutableArray *)links
{
    if (!_links) {
        NSMutableArray *links = [NSMutableArray array];

        // 搜索所有的链接
        [self.attributedText enumerateAttribute:GYLinkText inRange:NSMakeRange(0, self.attributedText.length) options:0 usingBlock:^(id value, NSRange range, BOOL *stop) {

            if (value == nil) return;

            GYLink *link = [[GYLink alloc] init];
            link.text = value;
            link.range = range;

            // 处理矩形框
            NSMutableArray *rects = [NSMutableArray array];
            // 设置字符选中的范围
            self.textView.selectedRange = range;
            // 计算选中字符范围的边框
            NSArray *selectionRects = [self.textView selectionRectsForRange:self.textView.selectedTextRange];
            for (UITextSelectionRect *selectionRect in selectionRects) {
                if (selectionRect.rect.size.width == 0 || selectionRect.rect.size.height == 0) continue;

                [rects addObject:selectionRect];
            }
            link.rects = rects;

            [links addObject:link];
        }];
        _links = links;
    }

    return _links;
}
</code></pre>

<p>这里，取出链接在属性文本中的范围，设置为textView的选中范围。然后会自动计算出textView中文本字符的范围。根据计算出边框，放在数组中<code>selectionRects</code>,然后保存到<code>link</code>对象的rects中。这样链接的文本边框就被保存起来了。接下来当点击链接的时候就可以高亮链接的边框了。</p>

<h4>在touchesBegan方法中，根据触摸点找出被点击的的链接。</h4>

<p>在touchesBegan方法中，根据被触摸的点计算出哪个链接被点击了。</p>

<pre><code>__block GYLink *touchingLink = nil;

[self.links enumerateObjectsUsingBlock:^(GYLink *link, NSUInteger idx, BOOL *stop) {
    for (UITextSelectionRect *selectionRect in link.rects) {
        if (CGRectContainsPoint(selectionRect.rect, point)) {
            touchingLink = link;
            break;
        }
    }
}];
</code></pre>

<p>这样，被点击的链接<code>touchingLink</code>就计算出来了。然后，高亮选中的链接边框。</p>

<h4>在被点击的链接的边框范围内添加高亮背景</h4>

<p>通过一个for循环，遍历的得到链接字符串所在的边框范围。</p>

<pre><code>for (UITextSelectionRect *selectionRect in link.rects) {
    UIView *view = [[UIView alloc] init];
    view.tag = GYLinkBackgroundTag;
    view.alpha = 0.5;
    view.layer.cornerRadius = 3;

    view.frame = selectionRect.rect;

    [self insertSubview:view atIndex:0];
    view.backgroundColor = GYColor(83, 148, 255);
}
</code></pre>

<p>然后在<code>touchCancelled</code>和<code>touchEnded</code>方法中将高亮的背景view给删除。</p>

<pre><code>dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.25 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
    for (UIView *view in self.subviews) {
        if (view.tag == GYLinkBackgroundTag) {
            [view removeFromSuperview];
        }
    }
});
</code></pre>

<p>为了能够获得这个背景view，前面给这个view添加了一个tag。最后，发送一个通知给控制器，让控制器决定链接点击事件进行处理。做出相应的跳转。</p>

<pre><code>    [[NSNotificationCenter defaultCenter] postNotificationName:GYLinkDidSelectedNotification object:nil userInfo:@{GYLinkText: touchingLink.text}];
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[实现新浪微博图文混排效果]]></title>
    <link href="http://conpgy.github.io/blog/2014/07/20/weibo-emotion-text/"/>
    <updated>2014-07-20T11:29:05+08:00</updated>
    <id>http://conpgy.github.io/blog/2014/07/20/weibo-emotion-text</id>
    <content type="html"><![CDATA[<p>通常，我们都会有图片和文字混合起来展示的需求。像杂志中展示一篇文章。QQ发送带表情文字的信息。微博的展示等等&hellip; 这里，我们简单的实现一下表情和文字的混合显示。模仿新浪微博，实现效果如下图：</p>

<p><img src="../../../../../pictures/weibo.png" alt="" /></p>

<p>我分为三大步骤：</p>

<ol>
<li>将表情插入到编辑框中</li>
<li>将带有表情的富文本转换为带有表情描述的普通文本，并发送给服务器</li>
<li>从服务器接收带有表情描述的普通文本，将表情描述解析成对应的表情</li>
</ol>


<!-- more -->


<p>查看完整代码，请点击<a href="https://github.com/conpgy/weibo-emotion-text/tree/emtionAndText">这里</a></p>

<h3>将表情插入到编辑框</h3>

<p>微博编辑框我们使用<code>GYEmotionTextView</code>，它继承自<code>GYTextView</code>, GYTextView继承自<code>UITextView</code>。<code>GYTextView</code>主要是增加了一个占位文字的功能。我们给<code>GYEmotionTextView</code>增加一个添加表情的方法<code>appendEmotion:</code>。具体实现如下：</p>

<pre><code>// GYEmotionTextView.m
/**
 *  在微博编辑框添加表情时调用
 *
 *  @param emotion 添加的表情
 */
-(void)appendEmotion:(GYEmotion *)emotion
{
    if (emotion.code) { // Emoji表情
    [self insertText:emotion.emoji];
    } else { // 图片表情
        NSMutableAttributedString *attributeText = [[NSMutableAttributedString alloc] initWithAttributedString:self.attributedText];


        // 创建一个带有图片表情的富文本
        GYEmotionAttachment *attachment = [[GYEmotionAttachment alloc] init];
        attachment.emotion = emotion;
        NSString *name = [NSString stringWithFormat:@"%@/%@", emotion.directory, emotion.png];
        attachment.image = [UIImage imageWithName:name];
        attachment.bounds = CGRectMake(0, -3, self.font.lineHeight, self.font.lineHeight);
        NSAttributedString *emotionStr = [NSMutableAttributedString attributedStringWithAttachment: attachment];

        // 记录表情的插入位置
        int insertIndex = self.selectedRange.location;
        // 插入表情到光标所在的位置
        [attributeText insertAttributedString:emotionStr atIndex:insertIndex];

        // 设置字体
        [attributeText addAttribute:NSFontAttributeName value:self.font range:NSMakeRange(0, attributeText.length)];

        self.attributedText = attributeText;

        // 让光标回到新插入表情的后面
        self.selectedRange = NSMakeRange(insertIndex + 1, 0);
    }

}
</code></pre>

<p>当我们从表情键盘选中一个表情时，就会在微博编辑框的光标位置插入对应的表情。<code>GYEmotionAttachment</code>集成自<code>NSTextAttachment</code>，<code>NSTextAttachment</code>是iOS7新增的类，有了它，就可以很方便的操控富文本了。这样，我们就可以对微博进行编辑了，效果如下：</p>

<p><img src="../../../../../pictures/send.png" alt="" /></p>

<p>当完成编辑后，就可以发送微博了。但是发送给服务器的一般都是普通的文本。因此，我们就不能这样发送了，需要将这个富文本，转换为普通的文本。</p>

<h3>将带有表情的富文本转换为带有表情描述的普通文本，并发送给服务器</h3>

<p>如何将富文本转换为普通文本呢？<code>NSAttributedString.h</code>有一个对象方法<code>- (void)enumerateAttributesInRange:(NSRange)enumerationRange options:(NSAttributedStringEnumerationOptions)opts usingBlock:(void (^)(NSDictionary *attrs, NSRange range, BOOL *stop))block</code>， 有了它，我们可以对富文本进行遍历，它会自动对这个文本进行切割，将普通文本和文本附件分离出来，通过block传递给我们,我们就可以通过字典<code>attrs</code>，通过关键字<code>NSAttachment</code>判断是否是表情。如下：</p>

<pre><code>NSMutableString *string = [NSMutableString string];

// 获得微博编辑框的富文本
NSAttributedString *attributeText = self.attributedText;

// 遍历富文本，将表情转换为文字描述
[attributeText enumerateAttributesInRange:NSMakeRange(0, self.attributedText.length) options:0 usingBlock:^(NSDictionary *attrs, NSRange range, BOOL *stop) {
    GYEmotionAttachment *attachment = attrs[@"NSAttachment"];
    if (attachment) {   //有表情
        [string appendString:attachment.emotion.chs];
    } else {    // 没有表情
        // 根据range范围获得富文本的文字内容
        NSString *subStr = [attributeText attributedSubstringFromRange:range].string;
        [string appendString:subStr];
    }
}];
</code></pre>

<p>这样我们就得到了带有表情描述的普通文本<code>string</code>，可以将它发送给服务器了。需要注意的是<code>GYEmotionAttachment</code>是我们自定义的，它继承自<code>NSTextAttachment</code>，给它添加一个属性emotion，就可以非常方便的获得传递过来的表情是哪个，然后找到对应的文字描述，进行字符串拼接。</p>

<h3>从服务器接收带有表情描述的普通文本，将表情描述解析成对应的表情</h3>

<p>我们其实就已经完成发送微博的功能了，可以该干嘛干嘛了。好好Happy一下了。OK，happy完后，如果我们需要浏览浏览别人的微博，就要向新浪的服务器发送请求，然后新浪将微博数据发送给我们，好，和发微博一样，服务器给客户端发送的数据一般也是文本。是没有表情的。因此，在客户端，我们需要对文本进行解析，转换成带有表情的微博。OK，世界瞬间又成了彩色的了。不过，这里，就比刚才稍显复杂了。要对文本进行解析，首先需要知道该怎么解析，解析成什么。像表情，一般是通过比如这样<code>[哈哈]</code>进行描述的。因此，我们需要对这样的文本进行查找，并替换。我们使用正在表达式，并使用第三方框架<code>RegexKitLite</code>。对文本进行匹配，将每一段普通文本和表情描述保存在数组<code>results</code>中，然后对数组进行排序。如下：</p>

<pre><code>/**
 *  根据文本计算出匹配结果
 *
 *  @param text 文本
 *
 *  @return 匹配结果数组
 */
- (NSArray *)regexResultsWithText:(NSString *)text
{
    // 存储匹配结果
    NSMutableArray *results = [NSMutableArray array];

    // 设置表情匹配格式
    NSString *emotionRegex = @"\\[[a-zA-Z0-9\\u4e00-\\u9fa5]+\\]";

    //遍历文本，根据表情格式匹配表情
    [text enumerateStringsMatchedByRegex:emotionRegex usingBlock:^(NSInteger captureCount, NSString *const __unsafe_unretained *capturedStrings, const NSRange *capturedRanges, volatile BOOL *const stop) {

        GYRegexResult *regexR = [[GYRegexResult alloc] init];
        regexR.string = *capturedStrings;
        regexR.range = *capturedRanges;
        regexR.emotion = YES;

        [results addObject:regexR];
    }];

    //遍历文本，根据表情格式匹配非表情
    [text enumerateStringsSeparatedByRegex:emotionRegex usingBlock:^(NSInteger captureCount, NSString *const __unsafe_unretained *capturedStrings, const NSRange *capturedRanges, volatile BOOL *const stop) {

        GYRegexResult *regexR = [[GYRegexResult alloc] init];
        regexR.string = *capturedStrings;
        regexR.range = *capturedRanges;
        regexR.emotion = NO;

        [results addObject:regexR];
    }];

    // 对匹配结果进行排序,(根据range的location，从小到大)
    [results sortUsingComparator:^NSComparisonResult(GYRegexResult *r1, GYRegexResult *r2) {
        int loc1 = r1.range.location;
        int loc2 = r2.range.location;

        return [@(loc1) compare:@(loc2)];
    }];

    return results;
}
</code></pre>

<p>得到这个数组后，就可以进行富文本的拼接了。如下：</p>

<pre><code>/**
 *  将带有表情描述的普通文本转换为富文本
 */
- (NSAttributedString *)attributeTextWithText:(NSString *)text
{
    NSMutableAttributedString *attributeText = [[NSMutableAttributedString alloc] init];

    // 根据本文计算出匹配结果
    NSArray *regexResults = [self regexResultsWithText:text];

    // 根据匹配结果拼接文本
    [regexResults enumerateObjectsUsingBlock:^(GYRegexResult *regexResult, NSUInteger idx, BOOL *stop) {
        if (regexResult.isEmotion) {    // 表情
            GYEmotionAttachment *attachment = [[GYEmotionAttachment alloc] init];
            attachment.emotion = [GYEmotionTool emotionWithDesc:regexResult.string];
            attachment.bounds = CGRectMake(0, -3, GYStatusTextFont.lineHeight, GYStatusTextFont.lineHeight);
            NSAttributedString *subStr = [NSAttributedString attributedStringWithAttachment:attachment];

            [attributeText appendAttributedString:subStr];
        } else {    // 非表情, 普通文本
            NSMutableAttributedString *subStr = [[NSMutableAttributedString alloc] initWithString:regexResult.string];

            [attributeText appendAttributedString:subStr];
        }
    }];


    // 设置字体
    [attributeText addAttribute:NSFontAttributeName value:GYStatusTextFont range:NSMakeRange(0, attributeText.length)];

    return attributeText;
}
</code></pre>

<p>这样，得到了富文本<code>attributeText</code>，好了，就可以直接进行展示了。如下图：</p>

<p><img src="../../../../../pictures/display.png" alt="" /></p>
]]></content>
  </entry>
  
</feed>
