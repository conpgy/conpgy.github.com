<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[无着的博客]]></title>
  <link href="http://conpgy.github.io/atom.xml" rel="self"/>
  <link href="http://conpgy.github.io/"/>
  <updated>2014-07-29T22:51:44+08:00</updated>
  <id>http://conpgy.github.io/</id>
  <author>
    <name><![CDATA[无着]]></name>
    <email><![CDATA[conpgy@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[自定义瀑布流控件]]></title>
    <link href="http://conpgy.github.io/blog/2014/07/29/waterflowview/"/>
    <updated>2014-07-29T21:43:14+08:00</updated>
    <id>http://conpgy.github.io/blog/2014/07/29/waterflowview</id>
    <content type="html"><![CDATA[<p>在移动APP中，瀑布流越来越流行。本篇自定义一个简单的瀑布流控件。首先，模仿UITableView,定义一个数据源和代理协议。数据源协议有三个方法。如下：</p>

<pre><code>@protocol GYWaterflowViewDataSource &lt;NSObject&gt;

@required
/** 有多少条数据 */
-(NSUInteger)numberOfCellsInWaterflowView:(GYWaterflowView *)waterflowView;

/** index位置对应的cell */
-(GYWaterflowViewCell *)waterflowView:(GYWaterflowView *)waterflowView cellAtIndex:(NSUInteger)index;

@optional
/** 有多少列 */
-(NSUInteger)numberOfColumnsInWaterflowView:(GYWaterflowView *)waterflowView;

@end
</code></pre>

<!-- more -->


<p>然后，定义协议的方法，如下：</p>

<pre><code>@protocol GYWaterflowViewDelegate &lt;UIScrollViewDelegate&gt;

@optional
/** index位置cell的高度 */
-(CGFloat)waterflowView:(GYWaterflowView *)waterflowView heightAtIndex:(NSUInteger)index;

/** 选中index处的cell */
-(void)waterflowView:(GYWaterflowView *)waterflowView didSelectAtIndex:(NSUInteger)index;

/** 返回间距 */
-(CGFloat)waterflowView:(GYWaterflowView *)waterflowView marginForType:(GYWaterflowViewMarginType)type;

@end
</code></pre>

<p>这样，在控制器中我们就可以像使用tableView一样的轻松的使用这个瀑布流控件了。在控制器中，可以如下这样使用它。</p>

<pre><code>#import "GYViewController.h"
#import "GYWaterflowView.h"
#import "GYWaterflowViewCell.h"

@interface GYViewController ()&lt;GYWaterflowViewDataSource, GYWaterflowViewDelegate&gt;

@end

@implementation GYViewController

- (void)viewDidLoad
{
    [super viewDidLoad];

    // 添加一个瀑布流控件
    GYWaterflowView *waterflowView = [[GYWaterflowView alloc] init];
    waterflowView.frame = self.view.bounds;
    waterflowView.dataSource = self;
    waterflowView.delegate = self;
    [self.view addSubview:waterflowView];
}

#pragma mark - waterflowView dataSoure

-(NSUInteger)numberOfCellsInWaterflowView:(GYWaterflowView *)waterflowView
{
    return 100;
}

-(GYWaterflowViewCell *)waterflowView:(GYWaterflowView *)waterflowView cellAtIndex:(NSUInteger)index
{
    static NSString *identifier = @"waterflowViewCell";
    GYWaterflowViewCell *cell = [waterflowView dequeueReusableCellWithIdentifier:identifier];

    if (cell == nil) {
        cell = [[GYWaterflowViewCell alloc] init];
        cell.identifier = identifier;
    }
    cell.backgroundColor = GYRandomColor;

    return cell;
}

#pragma mark - waterflowView delegate

-(CGFloat)waterflowView:(GYWaterflowView *)waterflowView heightAtIndex:(NSUInteger)index
{
    return (arc4random_uniform(40) + 70);
}

@end
</code></pre>

<p>效果如下图：</p>

<p><img src="../../../../../pictures/waterflowView.png" alt="" /></p>

<p>接下来，是如何实现<code>GYWaterflowView</code>。模仿tableView，定义一个<code>reloadData</code>方法，当调用这个方法时，会刷新里面的所有子控件。我们定义一个<code>GYWaterflowViewCell</code>作为它的子控件。在这个cell类中，提供一个<code>identifier</code>属性用来标识cell。在<code>reloadData</code>方法中，需要重新计算所有的cell的frame。然后在<code>layoutSubView</code>方法中将在屏幕上的cell显示出来。<code>reloadData</code>方法的具体实现如下：</p>

<pre><code>-(void)reloadData
{
    // 清空之前的数据
    [self.displayingCells.allValues makeObjectsPerformSelector:@selector(removeFromSuperview)];
    [self.displayingCells removeAllObjects];
    [self.cellFrames removeAllObjects];
    [self.reuseableCells removeAllObjects];

    // 数据总条数
    NSUInteger numberOfCells = [self.dataSource numberOfCellsInWaterflowView:self];

    // 总列数
    NSUInteger numberOfColumns = [self numberOfColumns];

    // 间距
    CGFloat topM = [self marginForType:GYWaterflowViewMarginTypeTop];
    CGFloat leftM = [self marginForType:GYWaterflowViewMarginTypeLeft];
    CGFloat rowM = [self marginForType:GYWaterflowViewMarginTypeRow];
    CGFloat columnM = [self marginForType:GYWaterflowViewMarginTypeColumn];
    CGFloat bottomM = [self marginForType:GYWaterflowViewMarginTypeBottom];

    // 计算cell的宽度
    CGFloat cellW = [self cellWidth];

    // 用一个C语言数组存放所有列的最大y值
    CGFloat maxYOfColumns[numberOfColumns];
    // 初始化
    for (int i = 0; i &lt; numberOfColumns; i++) {
        maxYOfColumns[i] = 0.0;
    }

    // 计算所有cell的frame
    for (int i = 0; i &lt; numberOfCells; i++) {
        // cell处在第几列
        NSUInteger cellColumn = 0;

        // cell所处那列的最大Y值(最短那一列的最大Y值)
        CGFloat cellMaxYOfColumn = maxYOfColumns[cellColumn];
        // 求出最短的一列
        for (int j = 1; j&lt;numberOfColumns; j++) {
            if (maxYOfColumns[j] &lt; cellMaxYOfColumn) {
                cellColumn = j;
                cellMaxYOfColumn = maxYOfColumns[j];
            }
        }

        // 计算出cell的位置
        CGFloat cellX = leftM + (cellW + columnM) * cellColumn;
        CGFloat cellY = 0;
        if (cellMaxYOfColumn == 0.0) {   // cell处在第一行
            cellY = topM;
        } else {
            cellY = cellMaxYOfColumn + rowM;
        }

        // cell的高度
        CGFloat cellH = [self heightAtIndex:i];

        // 计算出cell的frame
        CGRect cellFrame = CGRectMake(cellX, cellY, cellW, cellH);

        // 将cell的frame添加到数组中
        [self.cellFrames addObject:[NSValue valueWithCGRect:cellFrame]];

        // 更新cell所处列的最大y值
        maxYOfColumns[cellColumn] = CGRectGetMaxY(cellFrame);
    }

    // 设置contentSize
    CGFloat contentH = maxYOfColumns[0];
    for (int i = 1; i &lt; numberOfColumns; i++) {
        if (maxYOfColumns[i] &gt; contentH) {
            contentH = maxYOfColumns[i];
        }
    }
    contentH += bottomM;
    self.contentSize = CGSizeMake(0, contentH);

}
</code></pre>

<p>这样，每个cell的的frame都计算出来了，并保存在cellFrames数组中。也计算出来了waterflowView的contentSize。然后就可以在<code>layoutSubView</code>中，将在屏幕上的cell显示出来。<code>layoutSubViews</code>具体实现如下：</p>

<pre><code>-(void)layoutSubviews
{
    [super layoutSubviews];

    // cell总数
    NSUInteger numberOfCells = self.cellFrames.count;

    for (int i = 0; i &lt; numberOfCells; i++) {
        // 取出i位置的cellFrame
        CGRect cellFrame = [self.cellFrames[i] CGRectValue];

        // 从字典中取出i位置的cell
        GYWaterflowViewCell *cell = self.displayingCells[@(i)];

        // 判断cellFrame在不在屏幕上
        if ([self isInScreen:cellFrame]) {
            if (cell == nil) {
                cell = [self.dataSource waterflowView:self cellAtIndex:i];
                cell.frame = cellFrame;
                [self addSubview:cell];

                // 存放到字典中
                self.displayingCells[@(i)] = cell;
            }
        } else {
            if (cell) {
                // 从scrollView和displayingCells字典中删除
                [cell removeFromSuperview];
                [self.displayingCells removeObjectForKey:@(i)];

                // 存放到缓存池中
                [self.reuseableCells addObject:cell];
            }
        }
    }
}
</code></pre>

<p>通过每个cell的frame，计算这个cell是否在屏幕上，如果不是，则不显示，并且，如果这个cell刚从屏幕上移除，那么将它从<code>waterflowView</code>上移除，并且从正在显示的cell的字典中删除，然后放入缓存池中。如果cell的frame在屏幕范围内，那么需要判断这个cell在滚动之前是否已经在屏幕上了，如果在，则什么也不做，如果不在，则从数据源方法中获得这个cell并且添加到<code>waterflowView</code>中。<code>isInScreen:</code>方法实现如下：</p>

<pre><code>/**
 *  判断cell的frame是否显示在屏幕上
 */
- (BOOL)isInScreen:(CGRect)frame
{
    return ((CGRectGetMaxY(frame) &gt; self.contentOffset.y) &amp;&amp; (CGRectGetMinY(frame) &lt; self.contentOffset.y + self.bounds.size.height));
}
</code></pre>

<p>还有一个注意点是，当瀑布流控件添加到控制器的view中时，需要显示这个控件的内容，因此我们可以在<code>willMoveToSuperView:</code>方法中调用<code>reloadData</code>方法，让它一添加就进行显示。</p>

<p>还有一个注意点是，我们提供了cell的复用机制，<code>- (id)dequeueReusableCellWithIdentifier:(NSString *)identifier</code>的实现如下：</p>

<pre><code>-(id)dequeueReusableCellWithIdentifier:(NSString *)identifier
{
    __block GYWaterflowViewCell *reuseableCell = nil;

    [self.reuseableCells enumerateObjectsUsingBlock:^(GYWaterflowViewCell *cell, BOOL *stop) {
        if ([cell.identifier isEqualToString:identifier]) {
            reuseableCell = cell;
            *stop = YES;
        }
    }];

    if (reuseableCell) {
        [self.reuseableCells removeObject:reuseableCell];
    }

    return reuseableCell;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[属性文本的截取与事件处理]]></title>
    <link href="http://conpgy.github.io/blog/2014/07/24/attributedstring-event/"/>
    <updated>2014-07-24T18:57:49+08:00</updated>
    <id>http://conpgy.github.io/blog/2014/07/24/attributedstring-event</id>
    <content type="html"><![CDATA[<p>上一篇<a href="http://conpgy.github.io/blog/2014/07/20/weibo-emotion-text/">实现新浪微博图文混排</a>谈到了表情与文本的混合排列。属性文本可以有效的设置一段文本中的文字可以有不同的属性。比方微博文本中有话题，超链接，@某人等等。对这些文本需要进行高亮和事件处理。跳转到相应的微博或者链接等等。要实现这个功能，可以分成四个步骤：</p>

<ol>
<li>查找出所有的链接（用一个数组存放所有的链接）</li>
<li>在touchesBegan方法中，根据触摸点找出被点击的的链接。</li>
<li>在被点击的链接的边框范围内添加高亮背景</li>
<li>在touchesEnd中，移除高亮背景。并发出通知，通知相应的控制器进行事件处理。</li>
</ol>


<!-- more -->


<p>查看完整代码，请猛击<a href="http://github.com/conpgy">这里</a>。</p>

<h4>查找出所有的链接</h4>

<p>通过遍历属性文本，找出对应的链接。然后用一个<code>GYLink</code>模型保存起来。模型总有三个属性：</p>

<pre><code>/** 链接文字 */
@property (nonatomic, copy) NSString *text;

/** 链接范围 */
@property (nonatomic, assign) NSRange range;

/** 链接边框 */
@property (nonatomic, strong) NSArray *rects;
</code></pre>

<p>然后将所有的链接保存在一个数组中。代码如下：</p>

<pre><code>-(NSMutableArray *)links
{
    if (!_links) {
        NSMutableArray *links = [NSMutableArray array];

        // 搜索所有的链接
        [self.attributedText enumerateAttribute:GYLinkText inRange:NSMakeRange(0, self.attributedText.length) options:0 usingBlock:^(id value, NSRange range, BOOL *stop) {

            if (value == nil) return;

            GYLink *link = [[GYLink alloc] init];
            link.text = value;
            link.range = range;

            // 处理矩形框
            NSMutableArray *rects = [NSMutableArray array];
            // 设置字符选中的范围
            self.textView.selectedRange = range;
            // 计算选中字符范围的边框
            NSArray *selectionRects = [self.textView selectionRectsForRange:self.textView.selectedTextRange];
            for (UITextSelectionRect *selectionRect in selectionRects) {
                if (selectionRect.rect.size.width == 0 || selectionRect.rect.size.height == 0) continue;

                [rects addObject:selectionRect];
            }
            link.rects = rects;

            [links addObject:link];
        }];
        _links = links;
    }

    return _links;
}
</code></pre>

<p>这里，取出链接在属性文本中的范围，设置为textView的选中范围。然后会自动计算出textView中文本字符的范围。根据计算出边框，放在数组中<code>selectionRects</code>,然后保存到<code>link</code>对象的rects中。这样链接的文本边框就被保存起来了。接下来当点击链接的时候就可以高亮链接的边框了。</p>

<h4>在touchesBegan方法中，根据触摸点找出被点击的的链接。</h4>

<p>在touchesBegan方法中，根据被触摸的点计算出哪个链接被点击了。</p>

<pre><code>__block GYLink *touchingLink = nil;

[self.links enumerateObjectsUsingBlock:^(GYLink *link, NSUInteger idx, BOOL *stop) {
    for (UITextSelectionRect *selectionRect in link.rects) {
        if (CGRectContainsPoint(selectionRect.rect, point)) {
            touchingLink = link;
            break;
        }
    }
}];
</code></pre>

<p>这样，被点击的链接<code>touchingLink</code>就计算出来了。然后，高亮选中的链接边框。</p>

<h4>在被点击的链接的边框范围内添加高亮背景</h4>

<p>通过一个for循环，遍历的得到链接字符串所在的边框范围。</p>

<pre><code>for (UITextSelectionRect *selectionRect in link.rects) {
    UIView *view = [[UIView alloc] init];
    view.tag = GYLinkBackgroundTag;
    view.alpha = 0.5;
    view.layer.cornerRadius = 3;

    view.frame = selectionRect.rect;

    [self insertSubview:view atIndex:0];
    view.backgroundColor = GYColor(83, 148, 255);
}
</code></pre>

<p>然后在<code>touchCancelled</code>和<code>touchEnded</code>方法中将高亮的背景view给删除。</p>

<pre><code>dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.25 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
    for (UIView *view in self.subviews) {
        if (view.tag == GYLinkBackgroundTag) {
            [view removeFromSuperview];
        }
    }
});
</code></pre>

<p>为了能够获得这个背景view，前面给这个view添加了一个tag。最后，发送一个通知给控制器，让控制器决定链接点击事件进行处理。做出相应的跳转。</p>

<pre><code>    [[NSNotificationCenter defaultCenter] postNotificationName:GYLinkDidSelectedNotification object:nil userInfo:@{GYLinkText: touchingLink.text}];
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[实现新浪微博图文混排效果]]></title>
    <link href="http://conpgy.github.io/blog/2014/07/20/weibo-emotion-text/"/>
    <updated>2014-07-20T11:29:05+08:00</updated>
    <id>http://conpgy.github.io/blog/2014/07/20/weibo-emotion-text</id>
    <content type="html"><![CDATA[<p>通常，我们都会有图片和文字混合起来展示的需求。像杂志中展示一篇文章。QQ发送带表情文字的信息。微博的展示等等&hellip; 这里，我们简单的实现一下表情和文字的混合显示。模仿新浪微博，实现效果如下图：</p>

<p><img src="../../../../../pictures/weibo.png" alt="" /></p>

<p>我分为三大步骤：</p>

<ol>
<li>将表情插入到编辑框中</li>
<li>将带有表情的富文本转换为带有表情描述的普通文本，并发送给服务器</li>
<li>从服务器接收带有表情描述的普通文本，将表情描述解析成对应的表情</li>
</ol>


<!-- more -->


<p>查看完整代码，请点击<a href="https://github.com/conpgy/weibo-emotion-text/tree/emtionAndText">这里</a></p>

<h3>将表情插入到编辑框</h3>

<p>微博编辑框我们使用<code>GYEmotionTextView</code>，它继承自<code>GYTextView</code>, GYTextView继承自<code>UITextView</code>。<code>GYTextView</code>主要是增加了一个占位文字的功能。我们给<code>GYEmotionTextView</code>增加一个添加表情的方法<code>appendEmotion:</code>。具体实现如下：</p>

<pre><code>// GYEmotionTextView.m
/**
 *  在微博编辑框添加表情时调用
 *
 *  @param emotion 添加的表情
 */
-(void)appendEmotion:(GYEmotion *)emotion
{
    if (emotion.code) { // Emoji表情
    [self insertText:emotion.emoji];
    } else { // 图片表情
        NSMutableAttributedString *attributeText = [[NSMutableAttributedString alloc] initWithAttributedString:self.attributedText];


        // 创建一个带有图片表情的富文本
        GYEmotionAttachment *attachment = [[GYEmotionAttachment alloc] init];
        attachment.emotion = emotion;
        NSString *name = [NSString stringWithFormat:@"%@/%@", emotion.directory, emotion.png];
        attachment.image = [UIImage imageWithName:name];
        attachment.bounds = CGRectMake(0, -3, self.font.lineHeight, self.font.lineHeight);
        NSAttributedString *emotionStr = [NSMutableAttributedString attributedStringWithAttachment: attachment];

        // 记录表情的插入位置
        int insertIndex = self.selectedRange.location;
        // 插入表情到光标所在的位置
        [attributeText insertAttributedString:emotionStr atIndex:insertIndex];

        // 设置字体
        [attributeText addAttribute:NSFontAttributeName value:self.font range:NSMakeRange(0, attributeText.length)];

        self.attributedText = attributeText;

        // 让光标回到新插入表情的后面
        self.selectedRange = NSMakeRange(insertIndex + 1, 0);
    }

}
</code></pre>

<p>当我们从表情键盘选中一个表情时，就会在微博编辑框的光标位置插入对应的表情。<code>GYEmotionAttachment</code>集成自<code>NSTextAttachment</code>，<code>NSTextAttachment</code>是iOS7新增的类，有了它，就可以很方便的操控富文本了。这样，我们就可以对微博进行编辑了，效果如下：</p>

<p><img src="../../../../../pictures/send.png" alt="" /></p>

<p>当完成编辑后，就可以发送微博了。但是发送给服务器的一般都是普通的文本。因此，我们就不能这样发送了，需要将这个富文本，转换为普通的文本。</p>

<h3>将带有表情的富文本转换为带有表情描述的普通文本，并发送给服务器</h3>

<p>如何将富文本转换为普通文本呢？<code>NSAttributedString.h</code>有一个对象方法<code>- (void)enumerateAttributesInRange:(NSRange)enumerationRange options:(NSAttributedStringEnumerationOptions)opts usingBlock:(void (^)(NSDictionary *attrs, NSRange range, BOOL *stop))block</code>， 有了它，我们可以对富文本进行遍历，它会自动对这个文本进行切割，将普通文本和文本附件分离出来，通过block传递给我们,我们就可以通过字典<code>attrs</code>，通过关键字<code>NSAttachment</code>判断是否是表情。如下：</p>

<pre><code>NSMutableString *string = [NSMutableString string];

// 获得微博编辑框的富文本
NSAttributedString *attributeText = self.attributedText;

// 遍历富文本，将表情转换为文字描述
[attributeText enumerateAttributesInRange:NSMakeRange(0, self.attributedText.length) options:0 usingBlock:^(NSDictionary *attrs, NSRange range, BOOL *stop) {
    GYEmotionAttachment *attachment = attrs[@"NSAttachment"];
    if (attachment) {   //有表情
        [string appendString:attachment.emotion.chs];
    } else {    // 没有表情
        // 根据range范围获得富文本的文字内容
        NSString *subStr = [attributeText attributedSubstringFromRange:range].string;
        [string appendString:subStr];
    }
}];
</code></pre>

<p>这样我们就得到了带有表情描述的普通文本<code>string</code>，可以将它发送给服务器了。需要注意的是<code>GYEmotionAttachment</code>是我们自定义的，它继承自<code>NSTextAttachment</code>，给它添加一个属性emotion，就可以非常方便的获得传递过来的表情是哪个，然后找到对应的文字描述，进行字符串拼接。</p>

<h3>从服务器接收带有表情描述的普通文本，将表情描述解析成对应的表情</h3>

<p>我们其实就已经完成发送微博的功能了，可以该干嘛干嘛了。好好Happy一下了。OK，happy完后，如果我们需要浏览浏览别人的微博，就要向新浪的服务器发送请求，然后新浪将微博数据发送给我们，好，和发微博一样，服务器给客户端发送的数据一般也是文本。是没有表情的。因此，在客户端，我们需要对文本进行解析，转换成带有表情的微博。OK，世界瞬间又成了彩色的了。不过，这里，就比刚才稍显复杂了。要对文本进行解析，首先需要知道该怎么解析，解析成什么。像表情，一般是通过比如这样<code>[哈哈]</code>进行描述的。因此，我们需要对这样的文本进行查找，并替换。我们使用正在表达式，并使用第三方框架<code>RegexKitLite</code>。对文本进行匹配，将每一段普通文本和表情描述保存在数组<code>results</code>中，然后对数组进行排序。如下：</p>

<pre><code>/**
 *  根据文本计算出匹配结果
 *
 *  @param text 文本
 *
 *  @return 匹配结果数组
 */
- (NSArray *)regexResultsWithText:(NSString *)text
{
    // 存储匹配结果
    NSMutableArray *results = [NSMutableArray array];

    // 设置表情匹配格式
    NSString *emotionRegex = @"\\[[a-zA-Z0-9\\u4e00-\\u9fa5]+\\]";

    //遍历文本，根据表情格式匹配表情
    [text enumerateStringsMatchedByRegex:emotionRegex usingBlock:^(NSInteger captureCount, NSString *const __unsafe_unretained *capturedStrings, const NSRange *capturedRanges, volatile BOOL *const stop) {

        GYRegexResult *regexR = [[GYRegexResult alloc] init];
        regexR.string = *capturedStrings;
        regexR.range = *capturedRanges;
        regexR.emotion = YES;

        [results addObject:regexR];
    }];

    //遍历文本，根据表情格式匹配非表情
    [text enumerateStringsSeparatedByRegex:emotionRegex usingBlock:^(NSInteger captureCount, NSString *const __unsafe_unretained *capturedStrings, const NSRange *capturedRanges, volatile BOOL *const stop) {

        GYRegexResult *regexR = [[GYRegexResult alloc] init];
        regexR.string = *capturedStrings;
        regexR.range = *capturedRanges;
        regexR.emotion = NO;

        [results addObject:regexR];
    }];

    // 对匹配结果进行排序,(根据range的location，从小到大)
    [results sortUsingComparator:^NSComparisonResult(GYRegexResult *r1, GYRegexResult *r2) {
        int loc1 = r1.range.location;
        int loc2 = r2.range.location;

        return [@(loc1) compare:@(loc2)];
    }];

    return results;
}
</code></pre>

<p>得到这个数组后，就可以进行富文本的拼接了。如下：</p>

<pre><code>/**
 *  将带有表情描述的普通文本转换为富文本
 */
- (NSAttributedString *)attributeTextWithText:(NSString *)text
{
    NSMutableAttributedString *attributeText = [[NSMutableAttributedString alloc] init];

    // 根据本文计算出匹配结果
    NSArray *regexResults = [self regexResultsWithText:text];

    // 根据匹配结果拼接文本
    [regexResults enumerateObjectsUsingBlock:^(GYRegexResult *regexResult, NSUInteger idx, BOOL *stop) {
        if (regexResult.isEmotion) {    // 表情
            GYEmotionAttachment *attachment = [[GYEmotionAttachment alloc] init];
            attachment.emotion = [GYEmotionTool emotionWithDesc:regexResult.string];
            attachment.bounds = CGRectMake(0, -3, GYStatusTextFont.lineHeight, GYStatusTextFont.lineHeight);
            NSAttributedString *subStr = [NSAttributedString attributedStringWithAttachment:attachment];

            [attributeText appendAttributedString:subStr];
        } else {    // 非表情, 普通文本
            NSMutableAttributedString *subStr = [[NSMutableAttributedString alloc] initWithString:regexResult.string];

            [attributeText appendAttributedString:subStr];
        }
    }];


    // 设置字体
    [attributeText addAttribute:NSFontAttributeName value:GYStatusTextFont range:NSMakeRange(0, attributeText.length)];

    return attributeText;
}
</code></pre>

<p>这样，得到了富文本<code>attributeText</code>，好了，就可以直接进行展示了。如下图：</p>

<p><img src="../../../../../pictures/display.png" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OC中JSON和XML的解析]]></title>
    <link href="http://conpgy.github.io/blog/2014/07/13/oc-json-xml/"/>
    <updated>2014-07-13T13:50:24+08:00</updated>
    <id>http://conpgy.github.io/blog/2014/07/13/oc-json-xml</id>
    <content type="html"><![CDATA[<h3>JSON</h3>

<p>JSON是一种轻量级的数据格式，一般用于数据交互。服务器返回给客户端的数据一般都是JSON或者XML，当然除了下载文件。</p>

<p>JSON的格式很像OC中的字典和数组。</p>

<pre><code>{"name": "jack", "age": 10}
{"names": ["jack", "rose", "jim"]}
</code></pre>

<p>标准的JSON格式key必须用双引号。要想从JSON中挖掘具体的数据，需要对JSON进行解析。JSON转换为OC数据类型：</p>

<p><img src="../../../../../pictures/jsonOc.png" alt="" /></p>

<p>在iOS中，JSON的常见解析方案有四种</p>

<ul>
<li>第三方库：JSONKit、SBJson、TouchJSON</li>
<li>苹果自带：NSJSONSerialization(性能最好)</li>
</ul>


<p>NSJSONSerialization的常见方法</p>

<ul>
<li><p>JSON数据-OC对象</p>

<p>+(id)JSONObjectWithData:(NSData <em>)data options:(NSJSONReadingOptions)opt error:(NSError </em>)error;</p></li>
<li><p>OC对象-JSON数据</p>

<p>+(NSData *)dataWithJSONObject:(id)obj options:(NSJSONWritingOptions)opt error:(NSError **)error;</p></li>
</ul>


<h3>XML</h3>

<p>XML全称Extensible Markup Language。和JSON一样，也是常用的数据交互格式。一般称作XML文档。</p>

<p>XML的解析方式有两种：</p>

<ul>
<li>DOM：一次性将整个XML文档加载进内存，比较适合解析小文件</li>
<li>SAX：从根元素开始，按照顺序一个元素一个元素往下解析，比较适合解析大文件。</li>
</ul>


<p>在iOS中，解析XML的手段有很多。苹果原生的有NSXMLParser。SAX方式解析，使用简单。第三方框架有libxml2和GDataXML。libxml2使用纯C语言。同时支持DOM和SAX方式解析。GDataXML支持DOM方式解析，是有Google开发的。解析小文件用GDataXML。</p>

<h4>NSXMLParser的使用方法</h4>

<pre><code>// 传入XML数据，创建解析器
NSXMLParser *parser = [NSXMLParser alloc] initWithData:data];
// 设置代理，监听解析过程
parser.delegate = self;
// 开始解析
[parser parse];
</code></pre>

<p>NSXMLParser采取SAX方式解析，特点是事件驱动，下面的情况会通知代理。</p>

<ul>
<li>当扫描到文档（Document）的开始与结束</li>
<li>当扫描到元素（Element）的开始与结束</li>
</ul>


<p>当扫描到文档的开始时调用（开始解析）</p>

<pre><code>- (void)parserDidStartDocument:(NSXMLParser *)parser
</code></pre>

<p>当扫描到文档的结束时调用（解析完毕）</p>

<pre><code>- (void)parserDidEndDocument:(NSXMLParser *)parser
</code></pre>

<p>当扫描到元素的开始时调用（attributeDict存放着元素的属性）</p>

<pre><code>- (void)parser:(NSXMLParser *)parser didStartElement:(NSString *)elementName namaspaceURI:(NSString *)namespaceURI qualifiedName:(NSString *)qName attributes:(NSDictionary *)attributeDict;
</code></pre>

<p>当扫描到元素的结束时调用（attributeDict存放着元素的属性）</p>

<pre><code>- (void)parser:(NSXMLParser *)parser didEndElement:(NSString *)elementName namaspaceURI:(NSString *)namespaceURI qualifiedName:(NSString *)qName;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[朝阳寺禅修]]></title>
    <link href="http://conpgy.github.io/blog/2014/07/13/zhao-yang-si-shan-xiu/"/>
    <updated>2014-07-13T12:27:17+08:00</updated>
    <id>http://conpgy.github.io/blog/2014/07/13/zhao-yang-si-shan-xiu</id>
    <content type="html"><![CDATA[<p>一直想要去一个清净的地方体验一下。因缘一直都不太成熟。直到这个五一。因缘具足，在北京的朝阳寺参加了为期五天的禅修。</p>

<p>一年多前，应该是大三的时候，一切都感到很迷茫。一直在胡思乱想，不知道人生的意义所在，今后该何去何从。巧合之下，接触到了佛法。一下子有点豁然开朗的感觉。从小到大，心中存在的好多谜团，好多困惑。在佛学中得到了答案。从此，开始看一些佛学的书籍，了解如何是佛法。虽然，直到现在，对于佛法，了解的只是皮毛中的皮毛。但是人生感觉到了一个大的方向。三观的轮廓得到了基本的确定。因为了解了一点佛法的皮毛，发现了自己需要努力的地方太多太多。对于在家人，首先就是要积极上进，感悟生活的真善美。而要对佛法深入，需要多多亲近善知识。广结佛缘。</p>

<p><img src="../../../../../pictures/2.jpeg" alt="" /></p>

<!-- more -->


<p>四月三十号，从住的地方出发。坐地铁到东直门，然后坐上916公交，到达怀柔。在百度查询的时候，说要6个多小时才能到达，结果却是早了一半的时间都不止。因此，顺便在怀柔逛了一逛。之后，找了一个快餐店吃午饭，发现比北京的便宜多了。吃过之后，坐上一两黑公交。来到朝阳寺。刚下车，就看到一个很大的石阶往上通着。在上面的正中间，有一尊大的观音菩萨像。问了一个阿姨，朝阳禅修中心在哪，在阿姨的热心指导之下，找到了目标站。好吧，其实就是往下面走了几十米。此时，应该是下午两点半左右。看到前面有一块匾。上面刻着四个大字“守一不移”。然后看到一位女师兄站在门口，应该是来迎接到来的人。果然，在进去后，看到如蘍师傅也在里面，师傅很年轻。在我还没反应过来的时候，师傅就说把手机上交一下，然后就把手机交了。结果在接下来的一段时间内，手总是时不时的掏兜,总感觉少了点什么，然后才反应过来是没有手机。之后，师兄介绍了一下这几天的安排以及住宿问题。然后我就去宿舍把东西放下，在外面逛了一下。然后拿了一本书，在旁边的园子里看着。是一本净慧法师创办的刊物。后来才了解到净慧法师是虚云老和尚的弟子。是临济宗第44代传人。而现在明月法师为临济宗第45代法脉传人。在晚饭之前，随几个参加禅修的师兄到朝阳寺观看了一番。领略了朝阳寺著名的通天水梯。在往上走的时候，果然听到了咚咚的水声。非常清脆，很好听。然后看到左边的一座殿上挂着一个写着临济宗三个大字的牌子。游玩了一番之后，回到禅修中心吃饭。回来的时候，才发现参加禅修的师兄陆陆续续都到了。八点的时候举行了普茶会。开始的时候，一个师兄教我们唱《观音菩萨如秋月》。这个师兄唱的非常好。然后我们也跟着唱。不会的就跟着学。唱完后，朝阳寺的当家的正式出场，就是明月法师。法师非常的年轻。具体说了什么我都忘了。之后就是迎请这次禅修的带领师傅，崇洪法师。师父话不多，直接带领我们进入禅堂。初次见到禅房的时候，好兴奋。然后，师父教了我们一些禅修的规矩与仪式之后。终于迎来了第一次的打坐。打坐了大概半个小时。在这过程中，就是觉得坐垫很高，然后心里一直在打妄想。有可能太兴奋了。做完之后，就回去睡觉。正式迎接禅修的第一天。还是第一次这么早睡觉。</p>

<p><img src="../../../../../pictures/1.jpeg" alt="" /></p>

<p>第一天早上四点半起床。很少有这么早起床。以前觉得起这么早一天都会发困。发现这一天也不困。状态很好。除了打坐的时候。来到禅房，开始经行。以前没做过，虽在视屏上看过，感觉挺新鲜，挺好玩的。后来，在每次上座前都会经行。不过，几天下来，也还是没有掌握经行的原理和方法。只知道是一个很好的修行方法。有禅师在经行的时候就进入大光明境。经行大概十来分钟，开始打坐。相对于平时，感觉这个坐垫太高了。如果要双盘，自己都很困难。第一次坐的时候，说实话，都没有进入状态。做完一支香后，老师给我们讲解了一下打坐的一些规范和方法。六点差不多就吃饭去吃饭。来到食堂后，男众坐在左边，女众坐在右边。先有值日的师兄和义工师兄把碗筷给每个人摆好。坐好后，开始给一个一个添加饭和菜。添加好就可以开始吃了。吃完后就可以离开了。在吃饭前还是有仪式的。师父念一段经文。不知怎么描述。就是感谢佛陀，感谢众生的。就是饭不是白吃的。不过对我们来说，饭来张口，吃饭就走，就是太惬意了。只是辛苦了为我们准备饭菜的师兄。在心里还是应该感谢他们的。吃完后，有一部人负责打扫卫生。而我没什么事，回到宿舍。室友在看书。室友是人民大学毕业的博士，。后来才发现。自己的差距了。室友基本上一有空闲就是看书学习。而我基本上就是浪费时间，不知道做些什么。从这些小的细节就可以看出一个人的水准了。</p>

<p>八点后，回到禅房行香，然后打坐。就这样上午接着坐三支香。发现这一个上午都没有进入状态。要么是瞌睡，要么是头脑昏沉，或者妄想。在每一支香休息的间隙。在一个房间还有提供好多的茶水点心。随便怎么吃。后来每一天还有各种大补的汤。寺里的师父真是太贴心了。上午完后，休息到下午两点半。然后小参，说是小参，其实算不上。对于我们这些没有基础的童鞋来说。问的好些问题我都是耳不忍闻了。感觉来low了。不过师傅总是非常热心的回答。小参完继续打坐。到了晚上吃完饭。本来我以为晚上不吃饭的。好吧，师傅是怕我们被饿坏了。吃完饭，进入晚上。再继续坐一支香。坐完后，师傅进行开示。不过都开示了什么我都忘了。然后回去睡觉。回到宿舍，洗洗后，打坐了一天，真的是感觉有点累。之后几天也都是这样。三天后好多人就回去了，去上班了。而我因为没有班可上，就继续在这呆两天。</p>

<p>基本上，在前两天，打坐我都不在状态，从第三天开始，状态才慢慢上来了。而且由于和平常自己的习惯不一样。每一支香45分钟。有时候有些感觉了，但是时间到了，需要下坐。之后休息了十几分钟，再接着坐就又要重新开始了。在最后一天的时候，人都走的差不多了。如蘍师傅带领我们念经。以前自己也读诵过普贤行愿品。但是和念就差别太大了。师傅一口气就念了好久。内容好多。这念经也是博大精深啊。我们基本上一点都赶不上。到了下午，基本上所有的人都回去了。当然，我也就回去了。请了几本经书，又回到了北京。</p>

<p>总之，这一次参加这个活动，收获还是很多的。有机会应该精进，参加一个更专业的禅七。
PS. 本来是参加完了就写这篇文章。但是发现自己实在是没有写东西的天赋，本来都放弃了，到今天发现还有这个东西，随便几句就添上了。写作以后要慢慢练。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[对人生、宇宙的思考和态度]]></title>
    <link href="http://conpgy.github.io/blog/2014/04/27/dui-ren-sheng-%2C-yu-zhou-de-si-kao-he-tai-du/"/>
    <updated>2014-04-27T17:02:02+08:00</updated>
    <id>http://conpgy.github.io/blog/2014/04/27/dui-ren-sheng-,-yu-zhou-de-si-kao-he-tai-du</id>
    <content type="html"><![CDATA[<h3>西方思想体系的问题</h3>

<p>在希腊哲学，有两大形而上学体系的派别：一个是巴曼尼得斯的体系，他的基本范畴是being（存有）。另一个，就是赫拉克利特的思想体系，他针对着存有的生灭变化，变迁发展的世界（所谓万物流转说）。由这个生灭变化的动力世界，要成立一个主要的范畴，就是Becoming（变化）。可是从巴曼尼得斯的立场来看，这个Becoming的一切生灭变化，是不断在变迁发展，可以说属于非存有（non-being）。因此，希腊哲学领域有两大境界：一个是巴曼尼得斯的“永恒世界”。并且针对着这个永恒的世界建立了一个基本范畴，being；另一个是赫拉克利特从变迁发展而成“动力世界”，他存在于种种的being。至于这种变如何成为可能？就是要把being转变为non-being。但是这里有问题是being与non-being是如何联系的。</p>

<!--more-->


<p> 通过这种现象，从柏拉图的思想体系来看，他的第一种境界同第二种境界两相隔绝，而且第一种境界和第二种境界中间也是隔绝的。所以，从柏拉图开始，要把巴曼尼得斯和赫拉克利特两大学派结合起来。柏拉图提到，宇宙境界里面的划分是一件很容易的事。但是到底怎么把它们结合起来，却是一件很困难的事。尤其是针对两个不同世界所建立起来的两种不同的思想，在期间，到底该如何才能将它们结合起来？这等于要把纯粹本体论与超本体论结合起来。</p>

<p>一直到亚理斯多德，直到安瑟莫，还是在解决这一类问题。到近代哲学，把这个问题转换成另外一个研究途径，从知识论上面所从事的认识论的途径，就是要设法重新研究各种范畴的思想，到底该如何把它们结合起来。变形成了康德的哲学问题，黑格尔的哲学问题。而这些问题，自始至终都具有理论上的大困难，很难完美的解决。</p>

<h3>东方思想没有西方所遇到的问题</h3>

<p>从佛学的眼光来看，西方哲学的起点，就是以“我执”为出发点，然和展开了各自的思想体系。换句话说，对一切境界要采取一种观点，而那个观点的核心是一个人。他先肯定了个人价值，形成一个孤立的系统，然后再设想出一套对他所面对的世界是和自己相隔绝的思想。因此，西方哲学处处离不开“我执”的观念。而如果“我执”的观念去不掉的话，如何才能达到永恒世界的客观真理呢？西方人总是将它们所面临的“我执”世界，肯定为一个客观的存在体，不管是永恒的世界，还是流变无常的系统，只要是一显现出境界，就马上确认它为一个客观的真实。对于这种客观真实的确认，其实就是一个以自我为中心的关照者，以所关照的境界来作为探究的对象。自然就会产生错误。</p>

<p>可是在东方，却没有这种错误。中国哲学可以避免佛学上所批评的两种“执”。中国的儒家，道家等都是有一种天人合德思想。因此，在设想宇宙的时候，就不会置身于宇宙客体之外。而把自己变成孤立的、主观的、封闭的，而与宇宙隔绝起来。所谓“海阔从鱼跃，天高任鸟飞”，“道并行而不悖，万物并育而不害”，“天地与我并生，万物与我合一”。</p>

<h3>华严宗如何解决这个问题</h3>

<p>华严宗强调“法界缘起”，也就是“无穷缘起”的思想。由真如的实体所展开的宇宙万有，是由平等的真如所变现的差别的万有。而宇宙的实相，并不是在现象之外去另求实体。因为除了实体的真如之外并没有现象。所以真如是能缘起，而万法是所缘起。这就是现象即本体，因为一切诸法都是由真如全体所显现。因此，现象与现象之间相互融摄。而互望于一切诸法时，彼此平等一如。因此，宇宙万物都是根据这种缘起大系统笼罩。事事灵动，物物关联，法不孤起，仗境放生。于一毛孔中，就能呈现无量佛刹旷然安住，于一微尘中，可容纳三世诸佛普现佛事。从真空观来看，首先，拿“真空”的理想，依据上回向的方法，回向菩提。把整个下层世界齐等化。使现实归入理想，使它渐渐接近理想。第二个方面，那个理想不是空洞的，而是可以实现的理想，这个实现的条件，当然是以物质世界上面所具有的条件来实现。于是理想世界同现实世界的关系不能对立，不可能敌对，一定要互相依持、互相融惯，这就是“空色无碍”。同时，当最后这两种境界都经历之后，千万不要沾滞、停留在原地不动。再来看如何“空色无碍”、“明空即色”。在西方哲学上柏拉图所肯定的乖离问题，以及一直到近代都没有解决的问题。在华严宗的思想里面得到了解决。譬如，从“会色归空观”里面，要透过哲学的语言，把“空”、“有”两方面的关系，重新加以说明。“色不即空，以即空故”。这里，“色”指色体时，“色体”不是“断空”，因为它不是断空，它同“真空”不同。但是它可以同真空建立起联系。就是这个“即”，这个“即”不是逻辑的述词（logical predicatin）。它不是逻辑归属（logical attribution），它是逻辑函数（logical function）。是功能关系。这句话，用到了两套逻辑，即亚理斯多德的传统逻辑，和外在关系逻辑。而华严宗的最后归宿，就在于八面玲珑地生活于现实与理想之中。</p>

<p>而这，也应该是我们对生活抱有地态度。一方面，我们要积极进去，追求思想自由和精神解脱。同时，我们要用于面对这个现实的世界，帮助其他人远离苦海。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[科学和哲学不是万能的]]></title>
    <link href="http://conpgy.github.io/blog/2014/04/26/ke-xue-he-zhe-xue-bu-shi-mo-neng-de/"/>
    <updated>2014-04-26T22:33:55+08:00</updated>
    <id>http://conpgy.github.io/blog/2014/04/26/ke-xue-he-zhe-xue-bu-shi-mo-neng-de</id>
    <content type="html"><![CDATA[<p>生在这个时代的人，不可能不受时代的影响。但是如果我们受时代的影响过深，而不知道回过头来纠正时代的错误，而让它一直蔓延下去，或者，对于过去的思想，不明白过去的思想不属于这个时代，然而却加以否定，那是错误的。</p>

<!--more-->


<p>西方历史哲学就产生了这个根本错误。他们一提到逻辑，便以为一定是分析逻辑；一提到推理，一定是程序的三段论法的推理。近代数理逻辑却把蕴含，落入到if&hellip;then&hellip;命题的形式中。因此对于任何思想，假使要是真理的话，它一定是一个结论，这个结论的前面一定要具有一个可以作为根据的前提，但是在前提之前又要根据前提，前提的前提之前，又要有前提才可以，一直追求到最后，也是无法说明的。</p>

<p>近代西方哲学所应用的方法，往往偏向一极善巧的应用，经常会造成方法学上的缺陷。当把这种缺陷带进来后，本来是应用这一种方法，帮助我们建立一套思想系统，但是当我们接受这一种方法学的训练后，反而成为思想发展上的一种障碍。因此这会作茧自缚，把建立起来的差别境界，当作是一种真理，这就是思想上的偏见。一旦形成了偏见，你就不能够自由，不能超脱解放。</p>

<p>如果我们仅仅根据分析逻辑，自然会把宇宙的每一个部分给打散，可以了解到差别境界里面的各种独有的特点，但是同时这个宇宙也被打散了，变得支离破碎。 因此，我们需要具备一种能力，把打散的东西重新合拢起来，这样就引起了近代西方逻辑上所谓的关系逻辑（relational logic）。对于这个关系逻辑上的应用，一方面就是凭借数学，把这种逻辑的应用扩大，而应用到各种科学的领域中去。在各种科学中，仍以数学作为基本范畴的应用。而在数学里面的应用，就是把思想应用的方式，变成线性进程（linear progression）。所谓线性进程，在宇宙范围内，不论任何科学思想的发展，假使要使它成为有效的应用范畴。那么就一定要具足前因，后果。前面有论据根源，后面要有结论。</p>

<p>但是这种线性进程的推演方法。当前一直向前追溯，追溯当到最初的本源，而那个本源，在科学本身的领域，是不能够解决的。而如果向后一直推演，又是一个无穷级数。到最后，也是没有办法解决的。因为科学的思想是一个有限系统。向前追溯，追不到最初的本源，向后追溯，也追不出无穷的结果，其结果可以说是无限的。因此，科学之路穷矣！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用git管理自己的代码库]]></title>
    <link href="http://conpgy.github.io/blog/2014/04/26/yong-gitguan-li-zi-ji-de-dai-ma-ku/"/>
    <updated>2014-04-26T20:59:40+08:00</updated>
    <id>http://conpgy.github.io/blog/2014/04/26/yong-gitguan-li-zi-ji-de-dai-ma-ku</id>
    <content type="html"><![CDATA[<p>刚开始学习git，下面是两篇教你如何使用git管理代码的教程：</p>

<p><a href="http://my.oschina.net/moishalo/blog/72206">使用git管理自己的代码&mdash;简单使用流程</a></p>

<p><a href="http://serholiu.com/github-share-code">在GitHub上分享和展示你的代码</a></p>

<p>OK,看完上面这两篇博文差不多了解了。下面将一些基础的命令记录下来。</p>

<!--more-->


<p>进入自己需要同步的目录, 建立一个仓库</p>

<pre><code>cd ~/code
git init
</code></pre>

<p>选择要添加仓库的文件</p>

<pre><code>git add .
</code></pre>

<p>这里&#8217;.&lsquo;代表这个文件夹下的所有文件。</p>

<p>使用git status命令查看我们做过哪些修改，建议在提交前都调用一下这个命令，看看我们做过什么改动。</p>

<pre><code>git status
</code></pre>

<p>使用git commit命令将文件提交到本地的Repository中，也就是离线提交，这个时候是可以没有网络链接的。注意：m参数后面跟的是提交的注释，记录这次提交的改变</p>

<pre><code>git commit -m 'test'
</code></pre>

<p>使用git clone命令将GitHub中创建的Repository同步到目录中</p>

<pre><code>git clone git@github.com:conpgy/pgy.github.com.git
</code></pre>

<p>使用git push命令将代码提交到服务器中。git push命令后面可以跟分支名，新创建的Repository默认分支是master。如果不跟分支名，默认直接提交到主分支master上。</p>

<pre><code>git push -u origin master
</code></pre>

<p>好了，现在你就可以到你的项目网站上查看你的代码了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[三转四谛]]></title>
    <link href="http://conpgy.github.io/blog/2014/04/26/san-zhuan-si-di/"/>
    <updated>2014-04-26T19:10:57+08:00</updated>
    <id>http://conpgy.github.io/blog/2014/04/26/san-zhuan-si-di</id>
    <content type="html"><![CDATA[<p>小乘法门讲四谛叫三转四谛法轮。然后就是十二因缘。综合起来讲，有三十七菩提道品，大小乘佛学的基础都在这里，是大彻大悟，自己了生死而成佛之路。当然，并不是每个人即生就能成佛，然而作为佛学常识，想要修行的人不可不知。</p>

<p>四谛：苦、集、灭、道</p>

<p>三转：</p>

<ul>
<li><p>纯苦无乐</p></li>
<li><p>求解脱</p></li>
<li><p>十二因缘</p></li>
</ul>


<!-- more -->


<h3>一转&mdash;世间苦</h3>

<p>佛说世间都是苦的,非常的痛苦，没有快乐。这个世界上的人认为的快乐，是把轻度的痛苦颠倒，当成快乐。世界上纯苦无乐，分成八苦。生、老、病、死、怨憎会、爱别离、求不得、五阴炽盛苦。喜欢的人，喜欢的事，别离了，分开了。自己所希望的做不到，随时随地都在爱别离苦。不喜欢的人，不喜欢的事偏偏总是碰上，骑马找不到亲家，骑牛偏偏碰上了。一心想要发财做官，偏偏总是不如意。五阴又称五蕴。分别是色、受、想、行、识。色就是生理的地、水、火、风、空。“受”就是感觉，我们每天气候冷热，舒服不舒服，思想情感等都是。“想”就是思想，知觉。“行”是宇宙间的那个动力，生命的背后有一个动力，电能一样永远在发动。这个动力在哪，我们找不到，找到了才叫修行。我们为什么会生病衰老？为什么会痛苦？“识”就是精神方面的。佛学把生理、心里，整个人的身心两方面合起来叫做五蕴。</p>

<p>佛说了四谛因缘，第一步是消极地看人生。其实每个宗教都是这样的看法。所以，我们修行就是跳出生死，跳出物理世界痛苦的拘束。</p>

<h3>二转&mdash;求解脱</h3>

<p>这一切的苦是从哪里来的？都是“集”来的。集是因，苦是集的果。集是集中，抓来的。我们的生命像一个磁铁一样，我们一打坐，总是感觉这里痛，那里痛，心不能静下来。因为我们一坐，心刚要静下来，宇宙的一切能量痛苦就集中到你身上了。然后想起来，明天就要考试了，还要工作多少年才能买的起房，编程能力还是菜鸟级别，怎样才能提高？都在集过来。</p>

<p>苦集下面是灭道，要灭除一切痛苦，跳出物理世界的范围，只有得道才能做得到。道是灭的因，灭是道的果。灭就是涅磐。解脱了就是涅磐。</p>

<h3>三转&mdash;十二因缘</h3>

<p>“无明缘行，行缘识，识缘名色，名色缘六入，六入缘触，触缘受，受缘爱，爱缘取，取缘有，有缘生，生缘老死”。“六入缘触，触缘受”，我们的身体感觉到冷，热。这就是触、受。触，瑜伽叫相应，就是交感。一触就有交感，心理上就是舒服不舒服。比如我们按摩感觉很舒服。受，男女之间的那点事，就是荷尔蒙在作怪。那点荷尔蒙消耗掉就没有了。有爱就取，有取就有现有的世界。</p>

<p>死后还存在不存在呢？佛说死后还会来受报。死后一片无明，莫名其妙，黑茫茫的，什么都不知道，又来投胎了。至于是不是这样，我们死后或许就知道了，呵呵。。</p>

<p>无名爱取三烦恼， 行有二支属业道。</p>

<p>从识至受并生死， 七支同名一苦报。</p>

<p>识、名色、六入、触、爱、生、老死综合起来是苦报。
无明、爱、取三种属于根本烦恼。我们莫名其妙的自己支配了，莫名其妙支配自己，一切是爱，爱世界，爱名，爱财，爱权，爱情。我们拼命的去抓，这是三种根本烦恼。</p>

<p>十二因缘有个“行”，有个“有”。“行”就是生命的一股动力你停不了它。比如我们睡觉，我们的照样心脏一直在跳，血液一直在流动。生命活着永远有个行阴。像太阳月亮永远在太空里转动。修行，就是要认识它。这个动力是物质的，还是意识的？是心物一元的。行和有这两个部分何起来，就是我们讲的造业。这个造业，有人说是上帝造的，说是命运使我们这样。其实没有一个主宰，都是我们自己集过来的。佛学的这个“业”包括善业、恶业、不善不恶业。不善不恶是中性的，如果我们修行就是造道业。成佛就是造成佛的业。地狱众生就是造的地狱的业。我们做的每件事都是在造业。后面有个动能是业道。行有二支在十二因缘属于<em>业道</em>。</p>

<p>因缘的道理非常地深，所以无明起来一定缘行。譬如我们累了睡觉，睡了之后我们一定会醒来。假如睡是无明，醒来就是行。只要我们睡好了就一定会醒来，不管睡多久。刚刚一醒那个就是行，我们不知道自己是怎么醒来的。无明缘行，行缘识。醒来以后就有思想了，行接着就有识了，那个心意识起作用了。思想一来就有身体的感觉。识缘名色。名色就是身体的感觉，名是精神的意识，色就是身体，色就是地、水、火、风、空，是物质的。然后我们就要活动了，就是触，触就会有受。白天我们都在感受中，有各种各样的感受。然后就是爱，爱了就取，抓得很牢。取就缘有，家庭、父母、孩子、钱、车、房。然后我们老去，老了就会死。又回到了无明。</p>

<p>佛说这每一个动作，过程都是无主宰的，没有一个人给你做主，也不是上帝，也不是鬼，也不是神，也不是阎王，也不是菩萨；不是空洞自然而来的，它有物理的作用，有科学性。因为无主宰，非自然，所以叫缘起，缘生，因缘所生；性空，它的本性是空的，因缘本身并没有实在的东西。所以叫缘起性空。</p>

<h3>十二时辰与十二因缘</h3>

<p>十二因缘，其实跟中国文化的十二地支是一个道理。以至于我们的五行八卦。都是这个物理世界的一个转法。至于深入的，以后研究好之后在谈。</p>

<p>（本文是我学习南怀瑾大师《禅与生命的认识初讲》做的一个笔记，绝大部分的内容都是上面的，想要更深入了解的朋友可以看看那本书，我觉得讲的非常的好）</p>
]]></content>
  </entry>
  
</feed>
