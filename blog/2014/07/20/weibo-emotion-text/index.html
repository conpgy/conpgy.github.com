
<!DOCTYPE HTML>

<html>

<head>
	<meta charset="utf-8">
	<title>实现新浪微博图文混排效果 - 无着的博客</title>
	<meta name="author" content="无着">

	
	<meta name="description" content="实现新浪微博图文混排效果 通常，我们都会有图片和文字混合起来展示的需求。像杂志中展示一篇文章。QQ发送带表情文字的信息。微博的展示等等&hellip; 这里，我们简单的实现一下表情和文字的混合显示。模仿新浪微博，实现效果如下图： 我分为三大步骤： 将表情插入到编辑框中 &hellip;">
	

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="/atom.xml" rel="alternate" title="无着的博客" type="application/atom+xml">
	
	<link rel="canonical" href="http://conpgy.github.io/blog/2014/07/20/weibo-emotion-text/">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'>
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
			<header id="header" class="inner"><div class="profilepic">
	
	<script src="/javascripts/md5.js"></script>
	<script type="text/javascript">
		$(function(){
			$('.profilepic').append("<img src='http://www.gravatar.com/avatar/" + MD5("conpgy@gmail.com") + "?s=160' alt='Profile Picture' style='width: 160px;' />");
		});
	</script>
	
</div>
<hgroup>
  <h1><a href="/">无着的博客</a></h1>
  
    <h2>一即一切，一切即一</h2>
  
</hgroup>


<nav id="main-nav"><ul class="main">
    <li><a href="/">Blog</a></li>
    <li><a href="http://about.me/uzhuo">About me</a></li>
    <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
<nav id="sub-nav">
	<div class="social">
		
			<a class="email" href="mailto:conpgy@gmail.com" title="Email">Email</a>
		
		
		
		
		
			<a class="github" href="https://github.com/conpgy" title="GitHub">GitHub</a>
		
		
		
		
		
		
		
		
		
		
    	
    	
			<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
	</div>
</nav>
</header>				
			</div>
		</div>	
		<div class="mid-col">
			
				
			
			<div class="mid-col-container">
				<div id="content" class="inner"><article class="post" itemscope itemtype="http://schema.org/BlogPosting">
	<h1 class="title" itemprop="name">实现新浪微博图文混排效果</h1>
	<div class="entry-content" itemprop="articleBody"><p>通常，我们都会有图片和文字混合起来展示的需求。像杂志中展示一篇文章。QQ发送带表情文字的信息。微博的展示等等&hellip; 这里，我们简单的实现一下表情和文字的混合显示。模仿新浪微博，实现效果如下图：</p>

<p><img src="../../../../../pictures/weibo.png" alt="" /></p>

<p>我分为三大步骤：</p>

<ol>
<li>将表情插入到编辑框中</li>
<li>将带有表情的富文本转换为带有表情描述的普通文本，并发送给服务器</li>
<li>从服务器接收带有表情描述的普通文本，将表情描述解析成对应的表情</li>
</ol>


<!-- more -->


<p>查看完整代码，请点击<a href="https://github.com/conpgy/weibo-emotion-text">这里</a></p>

<h3>将表情插入到编辑框</h3>

<p>微博编辑框我们使用<code>GYEmotionTextView</code>，它继承自<code>GYTextView</code>, GYTextView继承自<code>UITextView</code>。<code>GYTextView</code>主要是增加了一个占位文字的功能。我们给<code>GYEmotionTextView</code>增加一个添加表情的方法<code>appendEmotion:</code>。具体实现如下：</p>

<pre><code>// GYEmotionTextView.m
/**
 *  在微博编辑框添加表情时调用
 *
 *  @param emotion 添加的表情
 */
-(void)appendEmotion:(GYEmotion *)emotion
{
    if (emotion.code) { // Emoji表情
    [self insertText:emotion.emoji];
    } else { // 图片表情
        NSMutableAttributedString *attributeText = [[NSMutableAttributedString alloc] initWithAttributedString:self.attributedText];


        // 创建一个带有图片表情的富文本
        GYEmotionAttachment *attachment = [[GYEmotionAttachment alloc] init];
        attachment.emotion = emotion;
        NSString *name = [NSString stringWithFormat:@"%@/%@", emotion.directory, emotion.png];
        attachment.image = [UIImage imageWithName:name];
        attachment.bounds = CGRectMake(0, -3, self.font.lineHeight, self.font.lineHeight);
        NSAttributedString *emotionStr = [NSMutableAttributedString attributedStringWithAttachment: attachment];

        // 记录表情的插入位置
        int insertIndex = self.selectedRange.location;
        // 插入表情到光标所在的位置
        [attributeText insertAttributedString:emotionStr atIndex:insertIndex];

        // 设置字体
        [attributeText addAttribute:NSFontAttributeName value:self.font range:NSMakeRange(0, attributeText.length)];

        self.attributedText = attributeText;

        // 让光标回到新插入表情的后面
        self.selectedRange = NSMakeRange(insertIndex + 1, 0);
    }

}
</code></pre>

<p>当我们从表情键盘选中一个表情时，就会在微博编辑框的光标位置插入对应的表情。<code>GYEmotionAttachment</code>集成自<code>NSTextAttachment</code>，<code>NSTextAttachment</code>是iOS7新增的类，有了它，就可以很方便的操控富文本了。这样，我们就可以对微博进行编辑了，效果如下：</p>

<p><img src="../../../../../pictures/send.png" alt="" /></p>

<p>当完成编辑后，就可以发送微博了。但是发送给服务器的一般都是普通的文本。因此，我们就不能这样发送了，需要将这个富文本，转换为普通的文本。</p>

<h3>将带有表情的富文本转换为带有表情描述的普通文本，并发送给服务器</h3>

<p>如何将富文本转换为普通文本呢？<code>NSAttributedString.h</code>有一个对象方法<code>- (void)enumerateAttributesInRange:(NSRange)enumerationRange options:(NSAttributedStringEnumerationOptions)opts usingBlock:(void (^)(NSDictionary *attrs, NSRange range, BOOL *stop))block</code>， 有了它，我们可以对富文本进行遍历，它会自动对这个文本进行切割，将普通文本和文本附件分离出来，通过block传递给我们,我们就可以通过字典<code>attrs</code>，通过关键字<code>NSAttachment</code>判断是否是表情。如下：</p>

<pre><code>NSMutableString *string = [NSMutableString string];

// 获得微博编辑框的富文本
NSAttributedString *attributeText = self.attributedText;

// 遍历富文本，将表情转换为文字描述
[attributeText enumerateAttributesInRange:NSMakeRange(0, self.attributedText.length) options:0 usingBlock:^(NSDictionary *attrs, NSRange range, BOOL *stop) {
    GYEmotionAttachment *attachment = attrs[@"NSAttachment"];
    if (attachment) {   //有表情
        [string appendString:attachment.emotion.chs];
    } else {    // 没有表情
        // 根据range范围获得富文本的文字内容
        NSString *subStr = [attributeText attributedSubstringFromRange:range].string;
        [string appendString:subStr];
    }
}];
</code></pre>

<p>这样我们就得到了带有表情描述的普通文本<code>string</code>，可以将它发送给服务器了。需要注意的是<code>GYEmotionAttachment</code>是我们自定义的，它继承自<code>NSTextAttachment</code>，给它添加一个属性emotion，就可以非常方便的获得传递过来的表情是哪个，然后找到对应的文字描述，进行字符串拼接。</p>

<h3>从服务器接收带有表情描述的普通文本，将表情描述解析成对应的表情</h3>

<p>我们其实就已经完成发送微博的功能了，可以该干嘛干嘛了。好好Happy一下了。OK，happy完后，如果我们需要浏览浏览别人的微博，就要向新浪的服务器发送请求，然后新浪将微博数据发送给我们，好，和发微博一样，服务器给客户端发送的数据一般也是文本。是没有表情的。因此，在客户端，我们需要对文本进行解析，转换成带有表情的微博。OK，世界瞬间又成了彩色的了。不过，这里，就比刚才稍显复杂了。要对文本进行解析，首先需要知道该怎么解析，解析成什么。像表情，一般是通过比如这样<code>[哈哈]</code>进行描述的。因此，我们需要对这样的文本进行查找，并替换。我们使用正在表达式，并使用第三方框架<code>RegexKitLite</code>。对文本进行匹配，将每一段普通文本和表情描述保存在数组<code>results</code>中，然后对数组进行排序。如下：</p>

<pre><code>/**
 *  根据文本计算出匹配结果
 *
 *  @param text 文本
 *
 *  @return 匹配结果数组
 */
- (NSArray *)regexResultsWithText:(NSString *)text
{
    // 存储匹配结果
    NSMutableArray *results = [NSMutableArray array];

    // 设置表情匹配格式
    NSString *emotionRegex = @"\\[[a-zA-Z0-9\\u4e00-\\u9fa5]+\\]";

    //遍历文本，根据表情格式匹配表情
    [text enumerateStringsMatchedByRegex:emotionRegex usingBlock:^(NSInteger captureCount, NSString *const __unsafe_unretained *capturedStrings, const NSRange *capturedRanges, volatile BOOL *const stop) {

        GYRegexResult *regexR = [[GYRegexResult alloc] init];
        regexR.string = *capturedStrings;
        regexR.range = *capturedRanges;
        regexR.emotion = YES;

        [results addObject:regexR];
    }];

    //遍历文本，根据表情格式匹配非表情
    [text enumerateStringsSeparatedByRegex:emotionRegex usingBlock:^(NSInteger captureCount, NSString *const __unsafe_unretained *capturedStrings, const NSRange *capturedRanges, volatile BOOL *const stop) {

        GYRegexResult *regexR = [[GYRegexResult alloc] init];
        regexR.string = *capturedStrings;
        regexR.range = *capturedRanges;
        regexR.emotion = NO;

        [results addObject:regexR];
    }];

    // 对匹配结果进行排序,(根据range的location，从小到大)
    [results sortUsingComparator:^NSComparisonResult(GYRegexResult *r1, GYRegexResult *r2) {
        int loc1 = r1.range.location;
        int loc2 = r2.range.location;

        return [@(loc1) compare:@(loc2)];
    }];

    return results;
}
</code></pre>

<p>得到这个数组后，就可以进行富文本的拼接了。如下：</p>

<pre><code>/**
 *  将带有表情描述的普通文本转换为富文本
 */
- (NSAttributedString *)attributeTextWithText:(NSString *)text
{
    NSMutableAttributedString *attributeText = [[NSMutableAttributedString alloc] init];

    // 根据本文计算出匹配结果
    NSArray *regexResults = [self regexResultsWithText:text];

    // 根据匹配结果拼接文本
    [regexResults enumerateObjectsUsingBlock:^(GYRegexResult *regexResult, NSUInteger idx, BOOL *stop) {
        if (regexResult.isEmotion) {    // 表情
            GYEmotionAttachment *attachment = [[GYEmotionAttachment alloc] init];
            attachment.emotion = [GYEmotionTool emotionWithDesc:regexResult.string];
            attachment.bounds = CGRectMake(0, -3, GYStatusTextFont.lineHeight, GYStatusTextFont.lineHeight);
            NSAttributedString *subStr = [NSAttributedString attributedStringWithAttachment:attachment];

            [attributeText appendAttributedString:subStr];
        } else {    // 非表情, 普通文本
            NSMutableAttributedString *subStr = [[NSMutableAttributedString alloc] initWithString:regexResult.string];

            [attributeText appendAttributedString:subStr];
        }
    }];


    // 设置字体
    [attributeText addAttribute:NSFontAttributeName value:GYStatusTextFont range:NSMakeRange(0, attributeText.length)];

    return attributeText;
}
</code></pre>

<p>这样，得到了富文本<code>attributeText</code>，好了，就可以直接进行展示了。如下图：</p>

<p><img src="../../../../../pictures/display.png" alt="" /></p>
</div>

</article>

	<div class="share">
	<div class="addthis_toolbox addthis_default_style ">
	
	
	
	<a class="addthis_counter addthis_pill_style"></a>
	</div>
  <script type="text/javascript" src="http://s7.addthis.com/js/250/addthis_widget.js#pubid="></script>
</div>



<section id="comment">
    <h1 class="title">Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
</section>
</div>
			</div>
			<footer id="footer" class="inner">Copyright &copy; 2014

    无着


Design credit: <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a></footer>
		</div>
	</div>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'uzhuo';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://conpgy.github.io/blog/2014/07/20/weibo-emotion-text/';
        var disqus_url = 'http://conpgy.github.io/blog/2014/07/20/weibo-emotion-text/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>





</body>
</html>
